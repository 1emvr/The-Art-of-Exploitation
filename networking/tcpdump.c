/*
 Author:    Lemur
 Github:    https://github.com/1emvr
 Email:     1emvr@protonmail.com
 Date:      12/26/2022  04:30 AM

 An excerpt from the book "Hacking: The Art of Exploitation, Vol 2"
 This is just reinventing the wheel: A tcpdump-type pcap packet capture and dumping tool.

 Analysis should be taken lightly as I am not an expert programmer 
 nor am I the greatest hacker.

 If there's anything wrong with my notes or perhaps 
 you might have some suggestions/ pointers/ corrections 
 then feel free to email/ DM me with any suggestions you may have. <3
*/
#include <pcap.h>

#include "multitool.h"
#include "network.h"
/*
    Calling in functions later defined.
*/
void pcap_fatal(const char *, const char *);
void decode_ethernet(const unsigned char *);
void decode_ip(const unsigned char *);
unsigned int decode_tcp(const unsigned char *);

void caught_packet(unsigned char *, const struct pcap_pkthdr *, const unsigned char *);

int main() {

    struct pcap_pkthdr pcap_header;
    const unsigned char *packet, *pkt_data;

    char errbuff[PCAP_ERRBUF_SIZE];
    char *device = pcap_lookupdev(errbuff);

    pcap_t *pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuff);

    if(device == NULL)
        pcap_fatal("pcap_lookupdev", errbuff);

    printf("Sniffing on device %s\n", device);

    if(pcap_handle == NULL)
        PCAP_FATAL("pcap_open_live", errbuff);

    pcap_loop(pcap_handle, 3, caught_packet, NULL);
    pcap_close(pcap_handle);
}

void caught_packet(unsigned char *user_args, const struct pcap_pkthdr *cap_header, const unsigned char *packet) {

    int tcp_header_length = decode_tcp(packet + ETHER_HDR_LEN + sizeof(struct i_header));
    int total_header_size = ETHER_HDR_LEN + sizeof(struct i_header) + tcp_header_length;
    int packet_data_len = cap_header -> len - total_header_size;
    
    unsigned char *packet_data = (unsigned char *) packet + total_header_size;

    printf("==== Got a %d byte packet ====\n", cap_header -> len);

    decode_ethernet(packet);
    decode_ip(packet + ETHER_HDR_LEN);

    if(packet_data_len > 0) {
        printf("\t\t\t%u bytes of packet data\n", packet_data_len);
        hexdump(packet_data, packet_data_len);
    } else
        printf("\t\t\tNo Packet Data\n");
}

void pcap_fatal(const char *failed_in, const char *errbuff) {
    printf("[!!] Fatal Error in %s: %s\n", failed_in, errbuff);
    exit(1);
}

void decode_ethernet(const unsigned char *header_start) {

    int i;
    const struct e_header *ethernet_header = (const struct e_header *) header_start;

    printf("[[  Layer 2 :: Ether Header ]]\n");
    printf("[   Source: %02x", ethernet_header -> ether_src_addr[0]);
    
    for( i=0; i<ETHER_ADDR_LEN; i++ )
        printf(":%02x", ethernet_header -> ether_src_addr[i]);

    printf("\tDest: %02x", ethernet_header -> ether_dest_addr[0]);

    for( i=0; i<ETHER_ADDR_LEN; i++ )
        printf(":%02x", ethernet_header -> ether_dest_addr[i]);

    printf("\tType: %hu ]\n", ethernet_header -> ether_type);
}

void decode_ip(const unsigned char *header_start) {

    const struct i_header *ip_header = (const struct i_header *) header_start;

    printf("\t((    Layer 3 ::: IP Header   ))\n");
    printf("\t(     Source: %s\t", inet_ntoa(ip_header -> ip_src_addr));
    printf("Dest: %s )\n", inet_ntoa(ip_header -> ip_dest_addr));
    printf("\t( Type: %u\t", (unsigned int) ip_header -> ip_type);
    printf("ID: %hu\tLength: %hu )\n", ntohs(ip_header -> ip_id), ntohs(ip_header -> ip_len));
}