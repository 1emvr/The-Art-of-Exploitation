/*
 Author: https://github.com/1emvr
 Email:  1emvr@protonmail.com
 Date:   12/19/2022  12:17 PM

 An excerpt from the book:
 "Hacking: The Art of Exploitation, Vol 2"

 This is an attempt to analyze the code provided in the book
 in greater detail than what their notes provide.
 I did not personally write this code.
 This is mainly for my notes.

 I tried making it more readable for myself
 and to practice my analysis skills

 If any part of my analysis is incorrect
 please feel free to email or DM me.

 I am more than open to suggestions and criticism
 and I'm always looking for suggestions. <3
*/

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>

#include "ec_malloc.h"

void fatal(char *);

int print_notes(int, int, char *);
int search_notes(char *, char *);
int find_user_notes(int, int);

int main(int argc, char *argv[]) {
/*
    We find our user's uid and set their permissions to our file descriptor.
    If we have more than one cli argument, then we know we have a searchstring.

    Then error-check if our file has been opened.
    While printing is true, call on the print_notes()
    which in-turn makes recursive calls to other functions
    in order to find a file with matching id's and
    search for a keyword.

    Once we've finished the complicated chain of events
    close the file and clear memory.
*/
    int printing = 1;
    int userid = getuid();
    int fd = open( argv[1], O_RDONLY );

    char searchstring[100];

    if(argc > 1)
        strcpy(searchstring, argv[2]);
    else
        searchstring[0] = 0;

    if(fd == -1)
        fatal("in main() while opening file for reading");

    while(printing)
        printing = print_notes(fd, userid, searchstring);

    printf("--------[ End of note data ]--------\n");
    close(fd);

    free((void *) fd);
    free((void *) printing);
}

int print_notes(int fd, int uid, char *searchstring) {
/*
    In order to find the note_length, we call on find_user_notes(),
    waiting for it to return the amount of bytes that matched the query.
    If the note_length reaches the end (-1) then we return 0.

    We read the note buffer for the note's length
    and then set the note_buffer to zero, terminating the line.

    We then call on the search_note() function, passing in our note buffer (*note)
    and a searchstring (*keyword), waiting for it to return a match.

    If there's a match in the search, print the note.
*/
    char byte = 0;
    char note_buffer[100];
    int note_length = find_user_notes(fd, uid);

    if(note_length == -1)
        return 0;

    read(fd, note_buffer, note_length);
    note_buffer[note_length] = 0;

    if(search_notes(note_buffer, searchstring))
        printf(note_buffer);

    return 1;
}

int search_notes(char *note, char *keyword) {
/*
    In search_notes() we start with a match-counter set to zero.
    We set a keyword length passed as an argument from the inputted
    keyword (searchstring) passed down from other function.

    If there is no search string, then "always match".

    Iterating over every character for the length of note,
    if the character matches the one in the keyword,
    then increment "match" and move to the next,

    Otherwise, if it matches the first keyword byte,
    start the match counter at 1, otherwise it's zero.

    Ultimately, once we have full length match, return "matched"
    Otherwise, return "not-matched".
*/
    int match = 0;
    int keyword_length = strlen(keyword);

    if(keyword_length == 0)
        return 1;

    for(int i = 0; i < strlen(note); i++) {

        if(note[i] == keyword[match]) {
            match++;
        } else {
            if(note[i] == keyword[0])
                match = 1;
            else
                match = 0;
        }
        if(match == keyword_length)
            return 1;
    }
    return 0;
}

int find_user_notes(int fd, int user_id) {
/*
    In find_user_notes() we cycle until the user_id
    and the note_uid are a match,
    initializing note_uid to -1.

    While reading, if the address of note_uid does not match
    by 4 bytes, we will continue with a negative result.
    If the address of our byte does not match
    then the same occurs.

    We then set both the byte and length to zero.

    While we haven't reached the end of the line in the file,
    we continue reading. If no match has been found it returns -1
    and continues to loop until we've found every byte that matches,
    incrementing the length each time.

    We then reset the file position indicator and print our findings.
*/
    unsigned char byte;

    int length;
    int note_uid = -1;

    while(note_uid != user_id) {
        if(read(fd, &note_uid, 4) != 4)
            return -1;
        if(read(fd, &byte, 1) != 1)
            return -1;

        byte = length = 0;

        while(byte != '\n') {
            if(read(fd, &byte, 1) != 1)
                return -1;

            length++;
        }
    }

    lseek(fd, length * -1, SEEK_CUR);

    printf("[DEBUG] found a %d byte note for user-id %d", length, note_uid);
    return length;
}
