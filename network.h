/*
 Author:    Lemur
 Email:     1emvr@protonmail.com
 Date:      12/25/2022  02:05 AM

 An excerpt taken from the book "Hacking: The Art of Exploitation, Vol 2"
 
 Collections of networking/ web service handlers, functions 
 and defining networking flags/ data structures.

*/
#define ETHER_ADDR_LEN 6
#define ETHER_HDR_LEN 14

struct ether_header {
/*
    Structs used to rename type-definitions from linux/if_ether.h
    We want more human readable names for our members while giving them datatypes.
*/
    unsigned char ether_dest_addr[ETHER_ADDR_LEN];
    unsigned char ether_src_addr[ETHER_ADDR_LEN];
    unsigned short ether_type;
};

struct ip_header {

    unsigned char ip_version_and_header_length;
    unsigned char ip_tos;
    unsigned short ip_len;
    unsigned short ip_id;
    unsigned short ip_frag_offset;
    unsigned char ip_ttl;
    unsigned char ip_type;
    unsigned short ip_checksum;
    unsigned int ip_src_addr;
    unsigned int ip_dest_addr;
};

struct tcp_header {

    unsigned short tcp_src_port;
    unsigned short tcp_dest_port;
    unsigned int tcp_seq;
    unsigned int tcp_ack;
    unsigned char reserved:4;
    unsigned char tcp_offset:4;
    unsigned char tcp_flags;

#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PUSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20

    unsigned short tcp_window;
    unsigned short tcp_checksum;
    unsigned short tcp_urgent;
};

int send_string(int sock_fd, unsigned char *buffer) {
/*
    A handler to send messages over TCP connections.

    Feeding in a buffer, we set bytes-to-send to it's length.

    While the bytes to send is not zero, we send the bytes over
    to the socket file descriptor. If our bytes fail to send
    then we have a fatal error.

    We continue to loop until we've run out of bytes to send,
    returning a success of 1.

*/
    int sent_bytes, bytes_to_send;
    bytes_to_send = strlen(buffer);

    while(bytes_to_send > 0) {
        sent_bytes = send(sock_fd, buffer, bytes_to_send, 0);
        if(sent_bytes == -1)
            return 0;

        bytes_to_send -= sent_bytes;
        buffer += sent_bytes;
    }
    return 1;
}

int recv_line(int sock_fd, unsigned char *dest_buffer) {
/*
    A handler to receive messages over TCP connections.

    We start by defining what end-of-line (EOL) should mean
    and the size in bytes.

    With an eol-matched-counter and the fed destination buffer,
    while the connection is "true", we check if our pointer is indeed
    EOL matched, incrementing it by one.

    If the eol-match is also the size we want, we create a new pointer
    with the value of our old pointer plus one and subtract the EOL Size
    and give it a null-terminator value, then return the size of our
    destination buffer.

    Otherwise, EOL is not a match. We finally increment "pointer".
*/
#define EOL "\r\n"
#define EOL_SIZE 2

    unsigned char *pointer;
    int eol_matched = 0;

    pointer = dest_buffer;

    while(recv(sock_fd, pointer, 1, 0) == 1) {
        if(*pointer == EOL[eol_matched]) {
            eol_matched++;
        
            if(eol_matched == EOL_SIZE) {
                *(pointer + 1 - EOL_SIZE) = '\0';
                return strlen(dest_buffer);
            }
        } else {

            eol_matched = 0;
        }
        pointer++;
    }
    return 0;
}
/*
    The functionality of receive line handler is still new to me.
    Understanding how this is scanning the streams, looking for any particular
    type of byte, finding an EOL is not something I've fully understood, yet.
*/