/*
 Author:    Lemur
 Email:     1emvr@protonmail.com
 Date:      12/25/2022  02:05 AM

 An excerpt taken from the book "Hacking: The Art of Exploitation, Vol 2"
 Collections of networking/web service handlers and functions.

*/
int send_string(int sock_fd, unsigned char *buffer) {
/*
    A handler to send messages over TCP connections.

    Feeding in a buffer, we set bytes-to-send to it's length.

    While the bytes to send is not zero, we send the bytes over
    to the socket file descriptor. If our bytes fail to send
    then we have a fatal error.

    We continue to loop until we've run out of bytes to send,
    returning a success of 1.

*/
    int sent_bytes, bytes_to_send;
    bytes_to_send = strlen(buffer);

    while(bytes_to_send > 0) {
        sent_bytes = send(sock_fd, buffer, bytes_to_send, 0);
        if(send_bytes == -1)
            return 0;

        bytes_to_send -= sent_bytes;
        buffer += send_bytes;
    }
    return 1;
}

int recv_line(int sock_fd, unsigned char *dest_buffer) {
/*
    A handler to receive messages over TCP connections.

    We start by defining what end-of-line (EOL) should mean
    and the size in bytes.

    With an eol-matched-counter and the fed destination buffer,
    while the connection is "true", we check if our pointer is indeed
    EOL matched, incrementing it by one.

    If the eol-match is also the size we want, we create a new pointer
    with the value of our old pointer plus one and subtract the EOL Size
    and give it a null-terminator value, then return the size of our
    destination buffer.

    Otherwise, EOL is not a match. We finally increment "pointer".
*/
#define EOL "\r\n"
#define EOL_SIZE 2

    unsigned char *pointer;
    int eol_matched = 0;

    pointer = dest_buffer;

    while(recv(sock_fd, pointer, 1, 0) == 1) {
        if(*pointer == EOL[eol_matched]) {
            eol_matched++;
        
            if(eol_matched == EOL_SIZE) {
                *(pointer + 1 - EOL_SIZE) = '\0';
                return strlen(dest_buffer);
            }
        } else {

            eol_matched = 0;
        }
        pointer++;
    }
    return 0;
}

/*
    The functionality of receive line handler is still new to me.
    Understanding how this is scanning the streams, looking for any particular
    type of byte, finding an EOL is not something I've fully understood, yet.
*/

void handle_connection(int sock_fd, struct sockaddr_in *client_addr_pointer) {
/*
    An HTTP connection handling service.

    Pass the socket file descriptor and request to the function
    "recv_line()", setting it's return value to "length".

    Printing the address and port number from the client,
    accessing the address pointer for addr:port from struct members
    sin_addr and sin_port, as well as printing the request itself.

    We then search for the substring "HTTP/" in the header and setting
    this to the pointer. If the pointer is NULL then it's not a real
    HTTP request. Otherwise, we point to zero and set "pointer" to NULL.

    We then compare the request's string to see if it's a GET or HEAD request.
    
    At this point, if the header does not contain any of these, 
    then the request is not known. 
    
    Otherwise, if we find the "/" in our header, 
    we know that the client is requesting the root directory 
    and we serve "index.html".

    We then set "resource" to "WEB_ROOT", which is defined elsewhere
    and concatenating the pointer to our resource.

    Next, we will open the resource as read-only.
    If the file is not found, we print the coresponding HTTP code
    Otherwise, we send an OK response.

    If we have a GET request and if getting the file fails
    then we have a fatal error. If we cannot allocate memory
    for "length" then we have a fatal error.

    We then read the file for it's length then send it.
*/
    unsigned char *pointer, request[500], resource[500];
    int fd, length;

    length = recv_line(sock_fd, request);
    printf("Received request from %s:%d \"%s\"\n", 
        
        inet_ntoa(client_addr_pointer -> sin_addr), 
        ntohs(client_addr_pointer -> sin_port), request
        );

    pointer = strstr(request, "HTTP/");

    if(pointer == NULL) {
        printf(" NOT HTTP!\n");
    } else {
        *pointer = 0;
        pointer = NULL;

        if(strncmp(request, "GET ", 4) == 0)
            pointer = request + 4;
        if(strncmp(request, "HEAD ", 5) == 0)
            pointer = request + 5;

        if(pointer == NULL) {
            printf("\tUNKNOWN REQUEST!\n");
        } else {
            if(pointer[strlen(pointer) - 1] == '/')
                strcat(pointer, "index.html");
            
            strcpy(resource, WEB_ROOT);
            strcat(resource, pointer);

            fd = open(resource, O_RDONLY, 0);
            printf("\tOpening \'%s\'\t", resource);

            if(fd == -1) {
                printf(" 404 Not Found\n");

                send_string(sock_fd, "HTTP/1.1 404 NOT FOUND\r\n");
                send_string(sock_fd, "Server: Tiny Webserver\r\n\r\n");
                send_string(sock_fd, "<html><head><title>404 Not Found</title></head>");
                send_string(sock_fd, "<body><h1>URL not found</h1></body></html>\r\n");
            } else {
                printf(" 200 OK\n");
                send_string(sock_fd, "HTTP/1.1 200 OK\r\n");
                send_string(sock_fd, "Server: Tiny Webserver\r\n\r\n");

                if(pointer == request + 4) {
                    if((length = get_file_size(fd)) == -1)
                        fatal("getting resource file size");
                    if((pointer = (unsigned char *) malloc(length)) == NULL)
                        fatal("allocating memory for reading resource");

                    read(fd, pointer, length);
                    send(sock_fd, pointer, length, 0);

                    free((void *) pointer);
                }
                close(fd);
            }
        }
    }
}

int get_file_size(int fd) {
/*
    A file size check function.

    If the file descriptor requested has failed,
    then we have a fatal error.

    Otherwise, we return the size as an integer.
*/
    struct stat stat_struct;

    if(fstat(fd, &stat_struct) == -1)
        return -1;
    return (int) stat_struct.st_size;
}