https://papers.vx-underground.org/papers

Register Key:
```
# Data Registers:
	- EAX, EBX, ECX, EDX
Lower Halves:
	- AX, BX, CX, DX
Higher Halves of Lower Halves:
	- AL, BL, CL, DL
Lower Halves of Lower Halves(funee):
	- AH, BH, CH, DH

AX: Primary Accumulator: I/O, Arithmatic instructions.
BX: Base Register: Used in indexed addressing.
CX: Count Register: ECX/CX registers store the loop count in iterative ops.
DX: Data Register: Also in I/O as well as withAX and DX for multiply/divide large values.

# Pointer Registers:
IP/CS: Instruction Pointer: 16-bit IP register stores offset addresses.
SP/SS: Stack Pointer: Offset value within the program stack. Current position of data.
BP: Base Pointer: Reference the parameter vars passed to subroutine.
Combined SS and BP to get the location of the parameter. BP/DI and SI as special addrs.

# Index Registers:
SI: Source Index: For string operations.
DI: Destination Index: For string operations.

# Control Registers:
OF: Overflow Flag: Indicates overflow of high-order bit after signed arithmatic ops.
DF: Directional Flag: Determines left or right direction for moving comparing str data.
IF: Interrupt Flag: Determines external interupts like keyboard entry, etc to ign/proc.
TF: Trap Flag: Allows setting ops of processor in single-step mode.
SF: Sign Flag: Shows sign of result of arithmatic operation.
ZF: Zero Flag: Indicates result of arithmetic or comparison ops.
AF: Auxiliary Carry Flag: COntains carry from 3-4 bit following math op.
PF: Parity Flag: Indicates total number of 1-bits in result.
CF: Carry Flag: Contains the carry of 0 or 1 from high-order bit after math op.

# Segment Registers:
- Copde Segment (CS): Instructions to be executed.
- Data Segment (DS): Data, constants and work areas.
- Stack Segment (SS): Contains data and return addresses.
- Extra Segment (ES): Refers to a seg in memory with another data segment.
```

8086 Instruction Key:
```
# General Purpose/ Word Transfer:
- MOV: Copies WORD/BYTE from dest, src.
- XCHG: Exchange contents or reg with another (MOV D<->S)
- XLAT/XLATB: Exchange byte in AL register from user table index to table entry addr.

- PUSH: Write a word to the stack
- POP: Read word from the stack

(*When WORD is popped from the stack: 
	Content moved from stack -> register,
	Value of stack pointer is incremented by two
);
(*When WORD is pushed onto the stack:
	Value of stack pointer is auto-decremented by two,
	Contents of the register written into the stack
);

- LEA, LDS and LES (Load Effective Address):
	lea: Load register with effective address
	lds: load register and Ds with words from memory
	les: load register and es with words from memory
```

Let's disassemble a virus. Any debugger should work:
```
 -u100
 14CF:0100 E99004        JMP     0593     ; Jumpt to the address 593h
 14CF:0103 3F            AAS              ; The rest of the code, as you
 14CF:0104 95            XCHG    BP,AX    ; can see, is encrypted and has
 14CF:0105 D7            XLAT             ; no sense at all %-)
 14CF:0106 29A6C13F      SUB     [BP+3FC1],SP
 14CF:010A 8FD7          POP     DI
 14CF:010C 29A2C13F      SUB     [BP+SI+3FC1],SP
 14CF:0110 16            PUSH    SS
 14CF:0111 D7            XLAT
 14CF:0112 7F6E          JG      0182
```

 Now we go to address 593h and find rest of the decrypted code:
```

 -u593
 14CF:0593 BE0001     MOV     SI,0100  ; 100h address of actual jmp 593h
 14CF:0596 56         PUSH    SI       ; Save SI
 14CF:0597 B94A02     MOV     CX,024A  ; Number of bytes to decrypt
 14CF:059A C70429D8   MOV     WORD PTR [SI],D829  ; d829 at 100h
 14CF:059E C64402C1   MOV     BYTE PTR [SI+02],C1 ; c1h at 102h
 14CF:05A2 8134C1D7   XOR     WORD PTR [SI],D7C1  ; d7c1h at SI. If we look
                                                  ; at 100h we'll find a
                                                  ; call c212h
```

If we now look at the header being decrypted, we find that at address `100h`, instead of a jump to `593h` there's a different instruction.

```
 -u100
 14CF:0100 E80FC1        CALL    C212  ; 100h address right now
 14CF:0103 3F            AAS
```

We continue decrypting...
```
 14CF:05A6 46         INC     SI   ; Increase SI, we get 101h
 14CF:05A7 46         INC     SI   ; Increase SI, we get 102h
 14CF:05A8 E2F8       LOOP    05A2 ; We decrpyt 24ah bytes which in CX
 14CF:05AA 31F6       XOR     SI,SI; Get a 0 at SI
 14CF:05AC 31C9       XOR     CX,CX; Get a 0 at CX
 14CF:05AE C3         RET
 14CF:05AF 0000       ADD     [BX+SI],AL
```