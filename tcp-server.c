/*
 Author:    Lemur
 Email:     1emvr@protonmail.com
 Data:      12/25/2022  01:07 AM

 An excerpt from the book "Hacking: The Art of Exploitation, Vol 2"

 I tried my best to analyze purely from reading/Googling and only refer
 to the book when I can't figure it out on my own.

 If any of my analysis is wrong or if you have any suggestions/pointers
 feel free to email/DM me. Constructive criticism is always appreciated.

 Merry xmas and a happy new year. <3
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "multitool.h"
#define PORT 8000

int main(void) {
/*
    A TCP-Connection server function.

    The host and client addresses are handled by
    a struct. We error check our socket and options to reuse address.

    We then set up the host address structure for the bind,
    using AF_INET as we want IPv4.

    The port is set to 8000. this short-integer must be converted
    to network byte-order, using H to NS. Setting address to 0 automatically
    sets our host's current IP address, requiring no conversion. We then set
    the remainder of sockaddr_in struct to zero.

    Using the "bind" function call, we pass the socket's fd, cast our struct to
    host_addr's memory address and make it "sockaddr-long". If this is not met,
    then we have a fatal error. While listening on sock_fd for up to five connections,
    if this does not succeed, we also have a fatal error.

    Next comes the loop that handles incoming connections.
    We set sin_size to sockadd_in's length. The new sock fd
    should accept incoming bytes from client_addr by sin_size.

    If the new connection fails, we receive a fatal error.
    We then send a message back ("Acknowleged." [12 characters])

    Our recieved length should equal the buffer's size up to 1024 bytes.
    This should continue to receive bytes until the connection stops,
    hexdumping our message by it's n length.
*/
    struct sockaddr_in host_addr, client_addr;

    int sock_fd, new_sock_fd;
    int recv_length = 1, yes = 1;
    char buffer[1024];

    socklen_t sin_size;

    if((sock_fd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
        fatal("in socket");
    if(setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)
        fatal("setting socket option SO_REUSEADDR");

    host_addr.sin_family = AF_INET;
    host_addr.sin_port = htons(PORT);
    host_addr.sin_addr.s_addr = 0;

    memset(&(host_addr.sin_zero), '\0', 8);

    if(bind(sock_fd, (struct sockaddr *) &host_addr, sizeof(struct sockaddr)) == -1)
        fatal("binding to socket");
    if(listen(sock_fd, 5) == -1)
        fatal("listening on socket");

    while(1) {
        sin_size = sizeof(struct sockaddr_in);
        new_sock_fd = accept(sock_fd, (struct sockaddr *) &client_addr, &sin_size);

        if(new_sock_fd == -1)
            fatal("accepting connection");
        
        printf("server: received connection from %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

        send(new_sock_fd, "Acknowleged.\n", 12, 0);
        recv_length = recv(new_sock_fd, &buffer, 1024, 0);

        while(recv_length > 0) {
            printf("RECV: %d bytes\n", recv_length);
            hexdump(buffer, recv_length);
        }
        close(new_sock_fd);
    }
    return 0;
}

/* 
    During testing, using telnet, the connection loops forever, 
    streaming "message" continuously and infinitely, unable to be stopped normally
    by an interup signal. I'm not sure why it behaves this way but it will be a note to keep for later. 
 */