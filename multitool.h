/*
 Author:    https://github.com/1emvr
 Email:     1emvr@protonmail.com
 Date:      12/19/2022  10:39   AM

 An excerpt from the book "Hacking: The Art of Exploitation, Vol 2"
 Collections of error checking functions.
*/

void fatal(char *message) {
/*
    This is just a simple error-printing handler.
    It will take errors returned from external functions
    and pass them here, appending the error code to our message.
*/
    char error_message[100];

    strcpy(error_message, "[!!] Fatal Error ");
    strncat(error_message, message, 83);
    perror(error_message);

    exit(-1);
}

void *ec_malloc(unsigned int size) {
/*
    A simple error-checking malloc() so that we don't have to include it
    every time we create a new piece of code. Malloc is passed a "size"
    externally and if it fails, the message returns an error
*/
    void *pointer;
    pointer = malloc(size);

    if(pointer == NULL)
        fatal("in ec_malloc() on memory allocation");

    return pointer;
}

void hexdump(const unsigned char *data_buffer, const unsigned int length) {
/*
    A hexdump function to pass a bytestream and decode to ASCII.

    While iterating through data, setting data_buffer to every passing
    byte, display the byte in hex format. If [i] modulous 16 is a byte
    short or the length minus one, then for each extra, print a space?

    Finally, print the characters along with. (Note needs revision)
*/
    unsigned char byte;
    unsigned int i, j;

    for( i=0; i<length; i++ ) {
        byte =  data_buffer[i];
        printf("%02x", data_buffer[i]);

        if(( i%16 ) == 15 || ( i==length - 1 )) {
            for( j=0; j<15-( i%16 ); j++ )
                printf(" ");
            printf("| ");

            for( j=(i-(i%16)); j<=i; j++ ) {
                byte = data_buffer[j];

                if(( byte>31 )&&( byte<127 ))
                    printf("%c", byte);
                else
                    printf(".");
            }
            printf("\n");
        }
    }
}
