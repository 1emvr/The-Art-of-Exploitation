/*
 Author:    https://github.com/1emvr
 Email:     1emvr@protonmail.com
 Date:      12/19/2022  10:39   AM

 An excerpt from the book "Hacking: The Art of Exploitation, Vol 2"

 A m
*/
void fatal(char *message) {
/*
    This is just a simple error-printing handler.
    It will take errors returned from external functions
    and pass them here, appending the error code to our message.
*/
    char error_message[100];

    strcpy(error_message, "[!!] Fatal Error ");
    strncat(error_message, message, 83);
    perror(error_message);

    exit(-1);
}

void *ec_malloc(unsigned int size) {
/*
    A simple error-checking malloc() so that we don't have to include it
    every time we create a new piece of code. Malloc is passed a "size"
    externally and if it fails, the message returns an error
*/
    void *pointer;
    pointer = malloc(size);

    if(pointer == NULL)
        fatal("in ec_malloc() on memory allocation");

    return pointer;
}

void dump(const unsigned char *data_buffer, const unsigned int length) {
/*
    A function to print raw bytes.

    Iterating over the data, let the data_buffer be set to every data byte,
    then print everything in hex format.

    If the modulous of each iterator (16 by half) is equal to 15, or the total
    length minus one, then iterating again for each, to the length of each segment,
    set data_buffer to each byte.

    Otherwise, print a dot (for none), then a new-line. 
    This will print raw bytes in the stream.
*/
    unsigned char byte;
    unsigned int i, j;

    for( i=0; i<length; i++ ) {
        byte = data_buffer[i];
        printf("%02x", data_buffer[i]);

        if(( i%16 ) == 15 || ( i==length - 1 )) {
            for( j=0; j<15 - (i%16); j++ ) {
                byte = data_buffer[j];

                if(( byte>31) && ( byte<127))
                    printf("%c", byte);
                else
                    printf(".");
            }
            printf("\n");
        }
    }
}
